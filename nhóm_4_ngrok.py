# -*- coding: utf-8 -*-
"""Nh√≥m 4_Ngrok.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18KN6b0KAOAN6R8brivSajJwqAZchbxkG
"""

# --- 1. C√†i ƒë·∫∑t c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt ---
!pip install streamlit plotly pandas seaborn pyngrok -q
!pip install pyngrok --upgrade -q

# --- 2. T·∫°o file app.py ---
# N·ªôi dung file: app.py
app_code = '''

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from datetime import datetime
import time
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.metrics import mean_squared_error
import numpy as np
import os # Added for path operations
import base64 # Added for image encoding

# ====== C·∫§U H√åNH GIAO DI·ªÜN T·ªêI ======
st.set_page_config(
    page_title="AirVision Analytics",
    page_icon="üåç",
    layout="wide",
    initial_sidebar_state="expanded"
)

# T√πy ch·ªânh CSS cho giao di·ªán t·ªëi
def local_css(file_name):
    with open(file_name) as f:
        st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)

# T·∫°o file CSS t·∫°m v·ªõi theme t·ªëi
custom_css = """
:root {
    --primary-color: #4a8fe7;
    --secondary-color: #2c3e50;
    --accent-color: #ff6b6b;
    --dark-color: #1a1a1a;
    --light-color: #f8f9fa;
}


.stApp {
    background-color: var(--dark-color);
    color: #ffffff;
}

/* Header */
header {
    background: linear-gradient(135deg, var(--primary-color), #3a7bd5);
    color: white !important;
    padding: 1rem 2rem !important;
    border-radius: 0 0 10px 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

/* Sidebar */
[data-testid="stSidebar"] {
    background-color: var(--secondary-color) !important;
    border-right: 1px solid #444;
    box-shadow: 2px 0 10px rgba(0,0,0,0.3);
    color: white;
}

/* Cards */
.custom-card {
    background: var(--secondary-color);
    color: white;
    border-radius: 10px;
    padding: 1.5rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    margin-bottom: 1.5rem;
    border-left: 4px solid var(--primary-color);
}

/* Buttons */
.stButton>button {
    border-radius: 8px !important;
    border: none !important;
    background-color: var(--primary-color) !important;
    color: white !important;
    transition: all 0.3s ease !important;
}

.stButton>button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3) !important;
}

/* Tabs */
[data-baseweb="tab-list"] {
    gap: 10px;
}

[data-baseweb="tab"] {
    padding: 8px 16px !important;
    border-radius: 8px !important;
    background-color: #34495e !important;
    color: white !important;
    transition: all 0.3s ease !important;
}

[data-baseweb="tab"]:hover {
    background-color: #2c3e50 !important;
}

[aria-selected="true"] {
    background-color: var(--primary-color) !important;
    color: white !important;
}

/* Progress bar */
.stProgress > div > div > div > div {
    background-color: var(--primary-color) !important;
}

/* Tables */
.stDataFrame {
    background-color: var(--secondary-color) !important;
    color: white !important;
}
"""

with open('styles.css', 'w') as f:
    f.write(custom_css)
local_css('styles.css')

# ====== ANIMATION & EFFECTS ======
def render_animated_header():
    st.markdown("""
    <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
            <h1 style="color: white; margin-bottom: 0;">üåç AirVision Analytics</h1>
            <p style="color: white; opacity: 0.9; margin-top: 0.5rem;">Tr·ª±c quan h√≥a d·ªØ li·ªáu ch·∫•t l∆∞·ª£ng kh√¥ng kh√≠ & kh√≠ t∆∞·ª£ng</p>
        </div>
        <div style="background: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px; display: flex; align-items: center;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 0.5rem;">
                <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 20C7.59 20 4 16.41 4 12C4 7.59 7.59 4 12 4C16.41 4 20 7.59 20 12C20 16.41 16.41 20 12 20Z" fill="white"/>
                <path d="M12 6C8.69 6 6 8.69 6 12C6 15.31 8.69 18 12 18C15.31 18 18 15.31 18 12C18 8.69 15.31 6 12 6ZM12 16C9.79 16 8 14.21 8 12C8 9.79 9.79 8 12 8C14.21 8 16 9.79 16 12C16 14.21 14.21 16 12 16Z" fill="white"/>
                <path d="M12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10Z" fill="white"/>
            </svg>
            <span style="color: white;">Real-time Monitoring</span>
        </div>
    </div>
    """, unsafe_allow_html=True)

# ====== H√ÄM T·∫¢I D·ªÆ LI·ªÜU ======
@st.cache_data
def load_data():
    url = "https://redcap.huph.edu.vn/ddp/tsa/nhom4.csv"
    try:
        # ƒê·ªçc file CSV t·ª´ URL
        df = pd.read_csv(url, sep=',', decimal='.', na_values=-200)

        # Ch·ªçn c√°c c·ªôt c·∫ßn thi·∫øt
        cols = ['Date', 'Time', 'CO(GT)', 'PT08.S1(CO)', 'NMHC(GT)', 'C6H6(GT)',
                'PT08.S2(NMHC)', 'NOx(GT)', 'PT08.S3(NOx)', 'NO2(GT)',
                'PT08.S4(NO2)', 'PT08.S5(O3)', 'T', 'RH', 'AH']
        df = df[cols]

        # Chuy·ªÉn ƒë·ªïi sang datetime v√† ƒë·∫∑t l√†m index
        df['Timestamp'] = pd.to_datetime(df['Date'] + ' ' + df['Time'])
        df = df.drop(columns=['Date', 'Time']).set_index('Timestamp')

        # X·ª≠ l√Ω gi√° tr·ªã thi·∫øu
        df = df.dropna()

        return df

    except Exception as e:
        st.error(f"L·ªói khi ƒë·ªçc d·ªØ li·ªáu: {str(e)}")
        return None


# ====== MAIN APP ======
def main():
    render_animated_header()

    # T·∫°o hi·ªáu ·ª©ng loading
    with st.spinner('ƒêang t·∫£i d·ªØ li·ªáu v√† kh·ªüi t·∫°o ·ª©ng d·ª•ng...'):
        time.sleep(1)

    # T·∫£i d·ªØ li·ªáu
    df = load_data()

    if df is None or df.empty:
        st.error("Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu ho·∫∑c d·ªØ li·ªáu tr·ªëng. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi ho·∫∑c ƒë·ªãnh d·∫°ng d·ªØ li·ªáu.")
        return

    # Ki·ªÉm tra c√°c c·ªôt c√≥ trong d·ªØ li·ªáu
    available_columns = df.columns.tolist()
    pollutants = ['CO(GT)', 'NOx(GT)', 'PT08.S5(O3)', 'C6H6(GT)', 'NMHC(GT)', 'NO2(GT)']
    weather = ['T', 'RH', 'AH']

    # ====== SIDEBAR HI·ªÜN ƒê·∫†I ======
    with st.sidebar:
        st.markdown("""
        <div style="display: flex; align-items: center; margin-bottom: 1.5rem;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 0.5rem;">
                <path d="M10 20V14H14V20H19V12H22L12 3L2 12H5V20H10Z" fill="#4a8fe7"/>
            </svg>
            <h2 style="margin: 0; color: white;">B·ªô l·ªçc d·ªØ li·ªáu</h2>
        </div>
        """, unsafe_allow_html=True)

        # Date/Time Filter
        with st.expander("üóìÔ∏è L·ªçc theo th·ªùi gian", expanded=True):
            min_date = df.index.min().date()
            max_date = df.index.max().date()

            col1, col2 = st.columns(2)
            with col1:
                start_date = st.date_input("T·ª´ ng√†y", min_date, key="start_date")
            with col2:
                end_date = st.date_input("ƒê·∫øn ng√†y", max_date, key="end_date")

            col3, col4 = st.columns(2)
            with col3:
                start_time = st.time_input("T·ª´ gi·ªù", datetime.strptime("00:00:00", "%H:%M:%S").time(), key="start_time")
            with col4:
                end_time = st.time_input("ƒê·∫øn gi·ªù", datetime.strptime("23:59:59", "%H:%M:%S").time(), key="end_time")

        # Bi·∫øn l·ª±a ch·ªçn
        with st.expander("üìä Ch·ªçn bi·∫øn hi·ªÉn th·ªã", expanded=True):
            st.markdown("**Ch·∫•t √¥ nhi·ªÖm**", help="Ch·ªçn c√°c ch·∫•t √¥ nhi·ªÖm ƒë·ªÉ hi·ªÉn th·ªã")
            selected_pollutants_flags = [] # Renamed to avoid conflict
            for poll in pollutants:
                if poll in available_columns:
                    selected_pollutants_flags.append(st.checkbox(poll, True, key=f"poll_{poll}"))
                else:
                    st.warning(f"Kh√¥ng t√¨m th·∫•y c·ªôt {poll} trong d·ªØ li·ªáu")

            st.markdown("**Th√¥ng s·ªë kh√≠ t∆∞·ª£ng**", help="Ch·ªçn c√°c th√¥ng s·ªë kh√≠ t∆∞·ª£ng ƒë·ªÉ hi·ªÉn th·ªã")
            selected_weather_flags = [] # Renamed to avoid conflict
            for w in weather:
                if w in available_columns:
                    selected_weather_flags.append(st.checkbox(w, True, key=f"weather_{w}"))
                else:
                    st.warning(f"Kh√¥ng t√¨m th·∫•y c·ªôt {w} trong d·ªØ li·ªáu")

    # ====== MAIN DASHBOARD ======
    # L·ªçc d·ªØ li·ªáu theo th·ªùi gian
    try:
        start_dt = datetime.combine(start_date, start_time)
        end_dt = datetime.combine(end_date, end_time)
        df_filtered = df[(df.index >= start_dt) & (df.index <= end_dt)]
    except Exception as e:
        st.error(f"L·ªói khi l·ªçc d·ªØ li·ªáu theo th·ªùi gian: {str(e)}")
        df_filtered = df.copy()

    # T·∫°o tabs
    tab1, tab2, tab3, tab4 = st.tabs(["üìà Dashboard", "üîç Ph√¢n t√≠ch", "üì§ D·ªØ li·ªáu", "üìä K·ªπ thu·∫≠t"])

    with tab1:
        # Th·ªëng k√™ nhanh
        st.markdown("### üìä T·ªïng quan d·ªØ li·ªáu")
        col1, col2, col3 = st.columns(3)
        with col1:
            st.markdown(f"""
            <div class="custom-card">
                <h3 style="color: var(--primary-color); margin-top: 0;">Th·ªùi gian</h3>
                <p>B·∫Øt ƒë·∫ßu: {df_filtered.index.min().strftime('%d/%m/%Y %H:%M')}</p>
                <p>K·∫øt th√∫c: {df_filtered.index.max().strftime('%d/%m/%Y %H:%M')}</p>
            </div>
            """, unsafe_allow_html=True)

        with col2:
            st.markdown(f"""
            <div class="custom-card">
                <h3 style="color: var(--primary-color); margin-top: 0;">S·ªë l∆∞·ª£ng d·ªØ li·ªáu</h3>
                <p>T·ªïng s·ªë m·∫´u: {len(df_filtered):,}</p>
                <p>S·ªë ng√†y: {(df_filtered.index.max() - df_filtered.index.min()).days + 1}</p>
            </div>
            """, unsafe_allow_html=True)

        with col3:
            avg_co = df_filtered['CO(GT)'].mean() if 'CO(GT)' in df_filtered.columns else 'N/A'
            avg_nox = df_filtered['NOx(GT)'].mean() if 'NOx(GT)' in df_filtered.columns else 'N/A'
            st.markdown(f"""
            <div class="custom-card">
                <h3 style="color: var(--primary-color); margin-top: 0;">Ch·∫•t l∆∞·ª£ng kh√¥ng kh√≠</h3>
                <p>CO trung b√¨nh: {avg_co if isinstance(avg_co, str) else f"{avg_co:.2f} ppm"}</p>
                <p>NOx trung b√¨nh: {avg_nox if isinstance(avg_nox, str) else f"{avg_nox:.2f} ppb"}</p>
            </div>
            """, unsafe_allow_html=True)

        st.markdown("### ‚ö†Ô∏è C·∫£nh b√°o ng∆∞·ª°ng √¥ nhi·ªÖm")

        # ƒê·ªãnh nghƒ©a ng∆∞·ª°ng c·∫£nh b√°o (c√≥ th·ªÉ thay ƒë·ªïi theo ti√™u chu·∫©n)
        thresholds = {
            'CO(GT)': {'low': 0, 'medium': 5, 'high': 10},  # ppm
            'NOx(GT)': {'low': 0, 'medium': 50, 'high': 100},  # ppb
            'C6H6(GT)': {'low': 0, 'medium': 5, 'high': 10},  # ¬µg/m¬≥
            'PT08.S5(O3)': {'low': 0, 'medium': 100, 'high': 200},  # ppb
            'NMHC(GT)': {'low': 0, 'medium': 200, 'high': 400},  # ppm
            'NO2(GT)': {'low': 0, 'medium': 100, 'high': 200}  # ppb
        }

        # T√≠nh to√°n s·ªë l·∫ßn v∆∞·ª£t ng∆∞·ª°ng
        alerts = []
        for poll, levels in thresholds.items():
            if poll in df_filtered.columns:
                high_alerts = len(df_filtered[df_filtered[poll] > levels['high']])
                med_alerts = len(df_filtered[(df_filtered[poll] > levels['medium']) & (df_filtered[poll] <= levels['high'])])

                alerts.append({
                    'Ch·∫•t √¥ nhi·ªÖm': poll,
                    'V∆∞·ª£t ng∆∞·ª°ng cao': high_alerts,
                    'V∆∞·ª£t ng∆∞·ª°ng trung b√¨nh': med_alerts,
                    'Ng∆∞·ª°ng cao': levels['high'],
                    'Ng∆∞·ª°ng trung b√¨nh': levels['medium']
                })

        if alerts:
            # Hi·ªÉn th·ªã b·∫£ng c·∫£nh b√°o
            st.dataframe(
                pd.DataFrame(alerts),
                use_container_width=True,
                hide_index=True
            )

            # Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì c·∫£nh b√°o
            fig_alerts = go.Figure() # Renamed to avoid conflict
            for poll_alert_data in alerts: # Iterate through alert data to get correct poll name
                poll_name = poll_alert_data['Ch·∫•t √¥ nhi·ªÖm']
                if poll_name in df_filtered.columns:
                    fig_alerts.add_trace(go.Scatter(
                        x=df_filtered.index,
                        y=df_filtered[poll_name],
                        name=poll_name,
                        mode='lines'
                    ))

                    # Th√™m ƒë∆∞·ªùng ng∆∞·ª°ng
                    fig_alerts.add_hline(
                        y=thresholds[poll_name]['high'],
                        line_dash="dot",
                        line_color="red",
                        annotation_text=f"Ng∆∞·ª°ng cao {poll_name}",
                        annotation_position="bottom right"
                    )
                    fig_alerts.add_hline(
                        y=thresholds[poll_name]['medium'],
                        line_dash="dash",
                        line_color="orange",
                        annotation_text=f"Ng∆∞·ª°ng TB {poll_name}",
                        annotation_position="bottom right"
                    )

            fig_alerts.update_layout(
                title="C·∫£nh b√°o v∆∞·ª£t ng∆∞·ª°ng √¥ nhi·ªÖm",
                yaxis_title="N·ªìng ƒë·ªô",
                template='plotly_dark'
            )
            st.plotly_chart(fig_alerts, use_container_width=True)
        else:
            st.info("Kh√¥ng c√≥ d·ªØ li·ªáu ch·∫•t √¥ nhi·ªÖm ƒë·ªÉ ki·ªÉm tra ng∆∞·ª°ng")

        # Bi·ªÉu ƒë·ªì ch√≠nh
        st.markdown("### üå°Ô∏è Bi·ªÉu ƒë·ªì theo d√µi")
        if not df_filtered.empty:
            fig_main_dashboard = make_subplots(specs=[[{"secondary_y": True}]]) # Renamed to avoid conflict

            # Th√™m d·ªØ li·ªáu ch·∫•t √¥ nhi·ªÖm
            for poll in [p for p in pollutants if p in df_filtered.columns]:
                fig_main_dashboard.add_trace(
                    go.Scatter(
                        x=df_filtered.index,
                        y=df_filtered[poll],
                        name=poll,
                        line=dict(width=2),
                        mode='lines',
                        hovertemplate="%{y:.2f}<extra></extra>"
                    ),
                    secondary_y=False
                )

            # Th√™m d·ªØ li·ªáu kh√≠ t∆∞·ª£ng
            for w in [w_param for w_param in weather if w_param in df_filtered.columns]: # Renamed inner variable
                fig_main_dashboard.add_trace(
                    go.Scatter(
                        x=df_filtered.index,
                        y=df_filtered[w],
                        name=w,
                        line=dict(dash='dot', width=1.5),
                        mode='lines',
                        hovertemplate="%{y:.2f}<extra></extra>"
                    ),
                    secondary_y=True
                )

            fig_main_dashboard.update_layout(
                height=500,
                template='plotly_dark',
                hovermode="x unified",
                legend=dict(
                    orientation="h",
                    yanchor="bottom",
                    y=1.02,
                    xanchor="right",
                    x=1
                ),
                margin=dict(l=20, r=20, t=40, b=20),
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)'
            )

            fig_main_dashboard.update_yaxes(title_text="N·ªìng ƒë·ªô ch·∫•t √¥ nhi·ªÖm", secondary_y=False)
            fig_main_dashboard.update_yaxes(title_text="Th√¥ng s·ªë kh√≠ t∆∞·ª£ng", secondary_y=True)

            st.plotly_chart(fig_main_dashboard, use_container_width=True)

    with tab2:
        st.markdown("### üî• Ph√¢n t√≠ch t∆∞∆°ng quan")
        # L·ªçc c√°c c·ªôt c√≥ trong d·ªØ li·ªáu
        available_vars = [v for v in pollutants + weather if v in df_filtered.columns]

        if len(available_vars) >= 2:
            corr_matrix = df_filtered[available_vars].corr()

            fig_corr, ax_corr = plt.subplots(figsize=(10, 8)) # Renamed
            sns.heatmap(
                corr_matrix,
                annot=True,
                fmt=".2f",
                cmap="coolwarm",
                center=0,
                square=True,
                linewidths=.5,
                cbar_kws={"shrink": .8},
                ax=ax_corr # Use renamed ax
            )
            plt.title("Ma tr·∫≠n t∆∞∆°ng quan gi·ªØa c√°c th√¥ng s·ªë", pad=20, color='white')
            ax_corr.set_facecolor('#2c3e50') # Use renamed ax
            fig_corr.patch.set_facecolor('#2c3e50') # Use renamed fig
            ax_corr.tick_params(axis='x', colors='white') # Use renamed ax
            ax_corr.tick_params(axis='y', colors='white') # Use renamed ax
            st.pyplot(fig_corr) # Use renamed fig

            # Ph√¢n t√≠ch xu h∆∞·ªõng
            st.markdown("### üìâ Ph√¢n t√≠ch xu h∆∞·ªõng")
            selected_trend = st.selectbox("Ch·ªçn th√¥ng s·ªë ƒë·ªÉ ph√¢n t√≠ch xu h∆∞·ªõng", available_vars)

            if selected_trend in df_filtered.columns:
                trend_fig = go.Figure()

                trend_fig.add_trace(
                    go.Scatter(
                        x=df_filtered.index,
                        y=df_filtered[selected_trend],
                        name='Gi√° tr·ªã th·ª±c',
                        line=dict(color='#4a8fe7')
                    )
                )

                # Th√™m ƒë∆∞·ªùng trung b√¨nh 7 ng√†y
                rolling_mean = df_filtered[selected_trend].rolling('7D').mean()
                trend_fig.add_trace(
                    go.Scatter(
                        x=rolling_mean.index,
                        y=rolling_mean.values,
                        name='Trung b√¨nh 7 ng√†y',
                        line=dict(color='#ff6b6b', dash='dash')
                    )
                )

                trend_fig.update_layout(
                    title=f"Xu h∆∞·ªõng {selected_trend}",
                    xaxis_title="Th·ªùi gian",
                    yaxis_title="Gi√° tr·ªã",
                    template='plotly_dark',
                    plot_bgcolor='rgba(0,0,0,0)',
                    paper_bgcolor='rgba(0,0,0,0)'
                )

                st.plotly_chart(trend_fig, use_container_width=True)

    with tab3:
        st.markdown("### üìÇ D·ªØ li·ªáu th√¥")

        # Hi·ªÉn th·ªã to√†n b·ªô d·ªØ li·ªáu d·∫°ng b·∫£ng
        st.dataframe(
            df_filtered,
            height=600,  # Chi·ªÅu cao c·ªë ƒë·ªãnh
            use_container_width=True,
            hide_index=True  # ·∫®n ch·ªâ s·ªë d√≤ng
        )

        # Th√¥ng tin t√≥m t·∫Øt trong expander
        with st.expander("‚ÑπÔ∏è Th√¥ng tin d·ªØ li·ªáu"):
            cols_info = st.columns(3) # Renamed to avoid conflict
            with cols_info[0]:
                st.metric("S·ªë d√≤ng", len(df_filtered))
            with cols_info[1]:
                st.metric("S·ªë c·ªôt", len(df_filtered.columns))
            with cols_info[2]:
                st.metric("D·ªØ li·ªáu thi·∫øu", df_filtered.isna().sum().sum())

        # T√πy ch·ªçn xu·∫•t d·ªØ li·ªáu
        st.markdown("### üì§ Xu·∫•t d·ªØ li·ªáu")
        export_format = st.radio("ƒê·ªãnh d·∫°ng xu·∫•t", ["CSV", "Excel"], horizontal=True)

        if st.button("Xu·∫•t d·ªØ li·ªáu ƒë√£ l·ªçc", type="primary"):
            if export_format == "CSV":
                csv_data = df_filtered.to_csv(index=True).encode('utf-8') # Renamed
                st.download_button(
                    label="T·∫£i xu·ªëng CSV",
                    data=csv_data, # Use renamed
                    file_name=f"air_quality_{start_date}_to_{end_date}.csv",
                    mime="text/csv"
                )
            else:
                from io import BytesIO
                output = BytesIO()
                with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                    df_filtered.to_excel(writer, index=True)
                excel_data = output.getvalue()
                st.download_button(
                    label="T·∫£i xu·ªëng Excel",
                    data=excel_data,
                    file_name=f"air_quality_{start_date}_to_{end_date}.xlsx",
                    mime="application/vnd.ms-excel"
                )
    with tab4:
        st.markdown("### üìä Ph√¢n t√≠ch chu·ªói th·ªùi gian n√¢ng cao")

        # Ch·ªçn bi·∫øn ƒë·ªÉ ph√¢n t√≠ch
        tech_analysis_var = st.selectbox(
            "Ch·ªçn bi·∫øn ƒë·ªÉ ph√¢n t√≠ch k·ªπ thu·∫≠t",
            [col for col in df.columns if col not in ['Date', 'Time']], # Ensure df is used, not df_filtered for full list
            key='tech_var'
        )

        if tech_analysis_var and tech_analysis_var in df_filtered.columns: # Check if var exists in filtered data
            series = df_filtered[tech_analysis_var].dropna()

            if series.empty:
                st.warning(f"Kh√¥ng c√≥ d·ªØ li·ªáu cho '{tech_analysis_var}' trong kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn sau khi lo·∫°i b·ªè NA.")
            else:
                # T·∫°o c√°c subtabs trong tab k·ªπ thu·∫≠t
                subtab1, subtab2, subtab3, subtab4 = st.tabs([
                    "Th√†nh ph·∫ßn m√πa v·ª•",
                    "T√≠nh d·ª´ng",
                    "T·ª± t∆∞∆°ng quan",
                    "Xu h∆∞·ªõng & Ngo·∫°i l·ªá"
                ])

                with subtab1:
                    st.markdown(f"#### Ph√¢n t√≠ch th√†nh ph·∫ßn m√πa v·ª• - {tech_analysis_var}")
                    if len(series) >= 48: # Period is 24, so need at least 2*period
                        try:
                            # T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh n·∫øu ch∆∞a t·ªìn t·∫°i
                            if not os.path.exists("charts/decomposition"):
                                os.makedirs("charts/decomposition")

                            # Th·ª±c hi·ªán decomposition
                            decomposition = seasonal_decompose(series, model='additive', period=24)

                            # V·∫Ω bi·ªÉu ƒë·ªì decomposition using Matplotlib
                            fig_decomp = decomposition.plot() # Renamed
                            fig_decomp.suptitle(f"Decomposition of {tech_analysis_var}", y=1.02)

                            # T√πy ch·ªânh m√†u s·∫Øc
                            axes_decomp = fig_decomp.get_axes() # Renamed
                            if len(axes_decomp) > 1 and len(axes_decomp[1].lines) > 0 : axes_decomp[1].lines[0].set_color('red')   # Trend
                            if len(axes_decomp) > 2 and len(axes_decomp[2].lines) > 0 : axes_decomp[2].lines[0].set_color('green') # Seasonal
                            if len(axes_decomp) > 3 and len(axes_decomp[3].lines) > 0 : axes_decomp[3].lines[0].set_color('orange')# Residual

                            # Th√™m grid
                            for ax_d in axes_decomp: # Renamed inner var
                                ax_d.grid(True)

                            plt.tight_layout()

                            # L∆∞u file ·∫£nh t·∫°m
                            temp_file_path = f"charts/decomposition/{tech_analysis_var}_decomp.png" # Renamed
                            plt.savefig(temp_file_path, bbox_inches='tight')
                            plt.close(fig_decomp) # Close the figure

                            # Hi·ªÉn th·ªã ·∫£nh trong Streamlit
                            with open(temp_file_path, "rb") as img_file: # Renamed
                                img_data = base64.b64encode(img_file.read()).decode()
                                img_html = f'<img src="data:image/png;base64,{img_data}" style="width:100%">'
                                st.markdown(img_html, unsafe_allow_html=True)

                            # Gi·∫£i th√≠ch k·∫øt qu·∫£
                            st.markdown("""
                            **Gi·∫£i th√≠ch th√†nh ph·∫ßn:**
                            - **Observed**: D·ªØ li·ªáu g·ªëc
                            - **Trend**: Xu h∆∞·ªõng d√†i h·∫°n
                            - **Seasonal**: Bi·∫øn ƒë·ªông theo m√πa (chu k·ª≥)
                            - **Residual**: Ph·∫ßn d∆∞ (nhi·ªÖu ng·∫´u nhi√™n)
                            """)

                        except Exception as e:
                            st.error(f"Kh√¥ng th·ªÉ ph√¢n t√≠ch th√†nh ph·∫ßn m√πa v·ª•: {str(e)}")
                            st.error(f"Chi ti·∫øt l·ªói: {repr(e)}")
                    else:
                        st.warning(f"Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch th√†nh ph·∫ßn m√πa v·ª• (c·∫ßn √≠t nh·∫•t 48 quan s√°t, hi·ªán c√≥ {len(series)})")

                with subtab2:
                    st.markdown(f"#### Ki·ªÉm tra t√≠nh d·ª´ng - {tech_analysis_var}")
                    if not series.empty:
                        try:
                            result_adfuller = adfuller(series) # Renamed

                            col_adf1, col_adf2 = st.columns(2) # Renamed
                            with col_adf1:
                                st.metric("ADF Statistic", f"{result_adfuller[0]:.4f}")
                                st.metric("p-value", f"{result_adfuller[1]:.4f}")

                            with col_adf2:
                                st.write("**Critical Values:**")
                                for key, value in result_adfuller[4].items():
                                    st.write(f"{key}: {value:.4f}")

                            if result_adfuller[1] > 0.05:
                                st.warning("Chu·ªói KH√îNG d·ª´ng (non-stationary)")
                                st.markdown("**G·ª£i √Ω:** C·∫ßn √°p d·ª•ng ph∆∞∆°ng ph√°p nh∆∞ differencing ƒë·ªÉ l√†m chu·ªói d·ª´ng")
                            else:
                                st.success("Chu·ªói d·ª´ng (stationary)")

                            # Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì so s√°nh v·ªõi rolling mean/std
                            fig_stationarity = go.Figure() # Renamed
                            fig_stationarity.add_trace(go.Scatter(x=series.index, y=series, name='Original'))
                            fig_stationarity.add_trace(go.Scatter(x=series.index, y=series.rolling(window=12).mean(), name='Rolling Mean'))
                            fig_stationarity.add_trace(go.Scatter(x=series.index, y=series.rolling(window=12).std(), name='Rolling Std'))

                            fig_stationarity.update_layout(
                                title=f"Ki·ªÉm tra t√≠nh d·ª´ng - {tech_analysis_var}",
                                template='plotly_dark'
                            )
                            st.plotly_chart(fig_stationarity, use_container_width=True)

                        except Exception as e:
                            st.error(f"Kh√¥ng th·ªÉ th·ª±c hi·ªán ADF test: {str(e)}")
                    else:
                        st.warning(f"Kh√¥ng c√≥ d·ªØ li·ªáu cho '{tech_analysis_var}' ƒë·ªÉ ki·ªÉm tra t√≠nh d·ª´ng.")


                with subtab3:
                    st.markdown(f"#### Ph√¢n t√≠ch t·ª± t∆∞∆°ng quan - {tech_analysis_var}")
                    if not series.empty:
                        col_acf, col_pacf = st.columns(2) # Renamed
                        with col_acf:
                            st.markdown("**Autocorrelation (ACF)**")
                            fig_acf = plot_acf(series, lags=40) # Renamed
                            st.pyplot(fig_acf)
                            plt.close(fig_acf) # Close the figure

                        with col_pacf:
                            st.markdown("**Partial Autocorrelation (PACF)**")
                            fig_pacf = plot_pacf(series, lags=40, method='ywmle') # Renamed, ywmle can cause issues with small samples
                            st.pyplot(fig_pacf)
                            plt.close(fig_pacf) # Close the figure


                        st.markdown("""
                        **Gi·∫£i th√≠ch:**
                        - ACF gi√∫p x√°c ƒë·ªãnh b·∫≠c q trong MA(q)
                        - PACF gi√∫p x√°c ƒë·ªãnh b·∫≠c p trong AR(p)
                        """)
                    else:
                        st.warning(f"Kh√¥ng c√≥ d·ªØ li·ªáu cho '{tech_analysis_var}' ƒë·ªÉ ph√¢n t√≠ch t·ª± t∆∞∆°ng quan.")

                with subtab4:
                    st.markdown(f"#### Ph√°t hi·ªán ngo·∫°i l·ªá - {tech_analysis_var}")
                    if not series.empty:
                        # T√≠nh to√°n v√† hi·ªÉn th·ªã outliers s·ª≠ d·ª•ng IQR
                        q1 = series.quantile(0.25)
                        q3 = series.quantile(0.75)
                        iqr = q3 - q1
                        lower_bound = q1 - 1.5 * iqr
                        upper_bound = q3 + 1.5 * iqr

                        outliers = series[(series < lower_bound) | (series > upper_bound)]

                        col_outlier1, col_outlier2 = st.columns(2) # Renamed
                        with col_outlier1:
                            st.metric("S·ªë l∆∞·ª£ng ngo·∫°i l·ªá", len(outliers))
                            if len(series) > 0 :
                                st.metric("T·ª∑ l·ªá ngo·∫°i l·ªá", f"{len(outliers)/len(series):.2%}")
                            else:
                                st.metric("T·ª∑ l·ªá ngo·∫°i l·ªá", "N/A")


                        with col_outlier2:
                            st.metric("Ng∆∞·ª°ng d∆∞·ªõi", f"{lower_bound:.2f}")
                            st.metric("Ng∆∞·ª°ng tr√™n", f"{upper_bound:.2f}")

                        # Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì v·ªõi outliers
                        fig_outliers = go.Figure() # Renamed
                        fig_outliers.add_trace(go.Scatter(
                            x=series.index,
                            y=series,
                            mode='lines',
                            name='D·ªØ li·ªáu'
                        ))
                        if not outliers.empty:
                            fig_outliers.add_trace(go.Scatter(
                                x=outliers.index,
                                y=outliers,
                                mode='markers',
                                marker=dict(color='red', size=8),
                                name='Ngo·∫°i l·ªá'
                            ))

                        fig_outliers.update_layout(
                            title=f"Ph√°t hi·ªán ngo·∫°i l·ªá - {tech_analysis_var}",
                            template='plotly_dark'
                        )
                        st.plotly_chart(fig_outliers, use_container_width=True)

                        # X·ª≠ l√Ω outliers
                        st.markdown("**X·ª≠ l√Ω ngo·∫°i l·ªá**")
                        method_outlier = st.selectbox( # Renamed
                            "Ph∆∞∆°ng ph√°p x·ª≠ l√Ω",
                            ["Kh√¥ng x·ª≠ l√Ω", "C·∫Øt ng∆∞·ª°ng", "Thay th·∫ø b·∫±ng trung v·ªã", "X√≥a b·ªè"],
                            key='outlier_method'
                        )

                        if st.button("√Åp d·ª•ng x·ª≠ l√Ω"):
                            series_processed = series.copy() # Start with a copy
                            if method_outlier == "C·∫Øt ng∆∞·ª°ng":
                                series_processed = series.clip(lower_bound, upper_bound)
                            elif method_outlier == "Thay th·∫ø b·∫±ng trung v·ªã":
                                median_val = series.median() # Renamed
                                series_processed = series.where(~((series < lower_bound) | (series > upper_bound)), median_val)
                            elif method_outlier == "X√≥a b·ªè":
                                series_processed = series[~series.index.isin(outliers.index)]

                            # Hi·ªÉn th·ªã k·∫øt qu·∫£
                            fig_processed = go.Figure() # Renamed
                            fig_processed.add_trace(go.Scatter(
                                x=series_processed.index,
                                y=series_processed,
                                mode='lines',
                                name='D·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω'
                            ))

                            fig_processed.update_layout(
                                title=f"D·ªØ li·ªáu sau x·ª≠ l√Ω - {tech_analysis_var}",
                                template='plotly_dark'
                            )
                            st.plotly_chart(fig_processed, use_container_width=True)

                            # C·∫≠p nh·∫≠t dataframe (Important: This modifies df_filtered for the current session only)
                            # df_filtered[tech_analysis_var] = series_processed # Be cautious with direct modification
                            st.success("ƒê√£ √°p d·ª•ng x·ª≠ l√Ω ngo·∫°i l·ªá (hi·ªÉn th·ªã). D·ªØ li·ªáu g·ªëc kh√¥ng thay ƒë·ªïi cho c√°c l·∫ßn ch·∫°y sau tr·ª´ khi l∆∞u l·∫°i.")
                    else:
                        st.warning(f"Kh√¥ng c√≥ d·ªØ li·ªáu cho '{tech_analysis_var}' ƒë·ªÉ ph√°t hi·ªán ngo·∫°i l·ªá.")


            st.markdown("### üîÆ ƒê√°nh gi√° m√¥ h√¨nh d·ª± b√°o ƒë∆°n gi·∫£n")

            if tech_analysis_var and tech_analysis_var in df_filtered.columns:
                series_for_forecast = df_filtered[tech_analysis_var].dropna() # Use the potentially processed series or original filtered
                if len(series_for_forecast) > 10: # Need enough data for train/test
                    # Chia train/test
                    train_size = int(len(series_for_forecast) * 0.8)
                    train, test = series_for_forecast[:train_size], series_for_forecast[train_size:]

                    if not test.empty and len(test) > 1:
                        # M√¥ h√¨nh naive (s·ª≠ d·ª•ng gi√° tr·ªã tr∆∞·ªõc ƒë√≥)
                        naive_forecast = test.shift(1).dropna() # Drop first NaN from shift
                        actual_values = test[1:] # Align with naive_forecast

                        if not naive_forecast.empty and not actual_values.empty and len(naive_forecast) == len(actual_values):
                            # T√≠nh to√°n c√°c ch·ªâ s·ªë
                            mse = mean_squared_error(actual_values, naive_forecast)
                            rmse = np.sqrt(mse)
                            mae = np.mean(np.abs(actual_values - naive_forecast))
                            mean_actual = np.mean(actual_values) # Renamed

                            col_metric1, col_metric2, col_metric3 = st.columns(3) # Renamed
                            with col_metric1:
                                st.metric("RMSE", f"{rmse:.2f}")
                            with col_metric2:
                                st.metric("MAE", f"{mae:.2f}")
                            with col_metric3:
                                if mean_actual != 0:
                                    st.metric("T·ª∑ l·ªá l·ªói (MAE/Mean)", f"{mae/mean_actual:.2%}")
                                else:
                                    st.metric("T·ª∑ l·ªá l·ªói (MAE/Mean)", "N/A (Mean is 0)")


                            # Hi·ªÉn th·ªã k·∫øt qu·∫£ d·ª± b√°o
                            fig_forecast = go.Figure() # Renamed
                            fig_forecast.add_trace(go.Scatter(
                                x=train.index,
                                y=train,
                                name='Train'
                            ))
                            fig_forecast.add_trace(go.Scatter(
                                x=test.index,
                                y=test,
                                name='Test'
                            ))
                            fig_forecast.add_trace(go.Scatter(
                                x=naive_forecast.index,
                                y=naive_forecast,
                                name='D·ª± b√°o Naive',
                                line=dict(dash='dot')
                            ))

                            fig_forecast.update_layout(
                                title=f"So s√°nh d·ª± b√°o Naive - {tech_analysis_var}",
                                template='plotly_dark'
                            )
                            st.plotly_chart(fig_forecast, use_container_width=True)

                            st.markdown("""
                            **Gi·∫£i th√≠ch:**
                            - M√¥ h√¨nh Naive s·ª≠ d·ª•ng gi√° tr·ªã t·∫°i th·ªùi ƒëi·ªÉm t-1 ƒë·ªÉ d·ª± b√°o cho th·ªùi ƒëi·ªÉm t.
                            - C√°c ch·ªâ s·ªë c√†ng th·∫•p c√†ng t·ªët.
                            - ƒê√¢y l√† baseline model ƒë·ªÉ so s√°nh v·ªõi c√°c m√¥ h√¨nh ph·ª©c t·∫°p h∆°n.
                            """)
                        else:
                            st.warning("Kh√¥ng ƒë·ªß d·ªØ li·ªáu sau khi t·∫°o d·ª± b√°o naive ƒë·ªÉ ƒë√°nh gi√°.")
                    else:
                        st.warning("Kh√¥ng ƒë·ªß d·ªØ li·ªáu trong t·∫≠p test ƒë·ªÉ th·ª±c hi·ªán d·ª± b√°o naive.")
                else:
                    st.warning(f"Kh√¥ng ƒë·ªß d·ªØ li·ªáu cho '{tech_analysis_var}' ƒë·ªÉ th·ª±c hi·ªán ƒë√°nh gi√° m√¥ h√¨nh d·ª± b√°o (c·∫ßn > 10 ƒëi·ªÉm d·ªØ li·ªáu).")
            else:
                st.info("Ch·ªçn m·ªôt bi·∫øn t·ª´ menu tr√™n ƒë·ªÉ xem ƒë√°nh gi√° m√¥ h√¨nh d·ª± b√°o.")


if __name__ == "__main__":
    main()
'''

with open('/content/app.py', 'w') as f:
    f.write(app_code)

# --- 3. Kh·ªüi ch·∫°y ·ª©ng d·ª•ng ---
from pyngrok import ngrok
import subprocess
import threading
import time
import requests

# Reset ngrok tunnels
ngrok.kill()

# C·∫•u h√¨nh Ngrok
NGROK_TOKEN = "2wIdHLEeJI9sBLsjQ3Lkt30ZYkT_33pMAYJokqqqyypmD9Zz9"  # üëà Thay token c·ªßa b·∫°n
ngrok.set_auth_token(NGROK_TOKEN)

# Kh·ªüi ch·∫°y Streamlit
def run_streamlit():
    subprocess.run([
        "streamlit", "run",
        "/content/app.py",
        "--server.port", "8501",
        "--server.headless", "true",
        "--browser.gatherUsageStats", "false"
    ])

threading.Thread(target=run_streamlit, daemon=True).start()

# Ch·ªù kh·ªüi ƒë·ªông
time.sleep(8)

# T·∫°o public URL
try:
    tunnel = ngrok.connect(8501, "http")
    public_url = tunnel.public_url
    print(f"\nüîó Truy c·∫≠p ·ª©ng d·ª•ng t·∫°i: {public_url}")
    print(f"üìä Xem dashboard Ngrok: https://dashboard.ngrok.com/status/tunnels")

except Exception as e:
    print(f"\n‚ùå L·ªói k·∫øt n·ªëi: {str(e)}")
    print("üëâ Nguy√™n nh√¢n th∆∞·ªùng g·∫∑p:")
    print("- H·∫øt h·∫°n token Ngrok")
    print("- Ch·∫°y qu√° 3 tunnel c√πng l√∫c (t√†i kho·∫£n mi·ªÖn ph√≠)")
    print("- L·ªói m·∫°ng")