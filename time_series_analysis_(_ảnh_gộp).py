# -*- coding: utf-8 -*-
"""Time series analysis ( Ảnh gộp).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UZsPzKHtn2PK5ZCL9mvmJefoL3KqkZbH

# **📚 1. IMPORT THƯ VIỆN CẦN THIẾT**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.metrics import mean_squared_error

# Cài đặt chung cho matplotlib và seaborn
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)

"""# **📚 2. ĐỌC DỮ LIỆU VÀ XỬ LÍ DỮ LIỆU**"""

# Đọc dữ liệu từ URL
DATA_PATH = "https://redcap.huph.edu.vn/ddp/tsa/nhom4.csv"
df = pd.read_csv(DATA_PATH, sep=',', decimal='.', na_values=-200)

# Chọn các cột cần thiết
cols = ['Date', 'Time', 'CO(GT)', 'PT08.S1(CO)', 'NMHC(GT)', 'C6H6(GT)',
        'PT08.S2(NMHC)', 'NOx(GT)', 'PT08.S3(NOx)', 'NO2(GT)',
        'PT08.S4(NO2)', 'PT08.S5(O3)', 'T', 'RH', 'AH']
df = df[cols]

# Chuyển đổi sang datetime và đặt làm index
df['Timestamp'] = pd.to_datetime(df['Date'] + ' ' + df['Time'])
df = df.drop(columns=['Date', 'Time']).set_index('Timestamp')

# Xử lý giá trị thiếu
df = df.dropna()

# Hiển thị thông tin cơ bản
print("Shape:", df.shape)
print("\nInfo:")
print(df.info())
print("\n5 dòng đầu tiên:")
print(df.head())

"""# **📚 3. PLOT DỮ LIỆU THÔ**

## **📚📚 3.1 Plot chất dữ liệu ô nhiễm**
"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# Tạo thư mục lưu ảnh
if not os.path.exists("charts"):
    os.makedirs("charts")

pollutants = ['CO(GT)', 'NMHC(GT)', 'C6H6(GT)', 'NOx(GT)', 'NO2(GT)']
image_tags = []

for col in pollutants:
    fig, ax = plt.subplots(figsize=(10, 5))  # 👉 Kích thước lớn hơn (ngang 10 inch)
    ax.plot(df.index, df[col], linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel('Concentration')
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')  # 👉 Lưu gọn sát nội dung
    plt.close(fig)

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        # 👉 Ảnh hiển thị rộng hơn: 700px
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# 👉 HTML xếp ảnh ngang, cuộn ngang được
html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""## **📚📚 3.2 Plot thời tiết**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# Tạo thư mục lưu ảnh nếu chưa có
if not os.path.exists("charts"):
    os.makedirs("charts")

meteo = ['T', 'RH', 'AH']
image_tags = []

for col in meteo:
    fig, ax = plt.subplots(figsize=(10, 5))  # Kích thước ảnh ngang 10 inch, cao 5 inch
    ax.plot(df.index, df[col], color='orange', linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel(col)
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')  # Lưu ảnh gọn sát nội dung
    plt.close(fig)  # Đóng ảnh để tránh tốn bộ nhớ

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# Tạo HTML để hiển thị ảnh theo hàng ngang và có thể cuộn ngang
html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""## **📚📚 3.3 Plot sensor**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# Tạo thư mục lưu ảnh nếu chưa có
if not os.path.exists("charts"):
    os.makedirs("charts")

sensors = ['PT08.S1(CO)', 'PT08.S2(NMHC)', 'PT08.S3(NOx)', 'PT08.S4(NO2)', 'PT08.S5(O3)']
image_tags = []

for col in sensors:
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(df.index, df[col], color='green', linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel(col)
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')
    plt.close(fig)

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""# **📚 4. PHÂN TÍCH THÀNH PHẦN MÙA VỤ (SEASONAL DECOMPOSITION)**"""

import matplotlib.pyplot as plt
import os
from statsmodels.tsa.seasonal import seasonal_decompose
from PIL import Image
from IPython.display import display
import math

# Tạo thư mục lưu ảnh decomposition nếu chưa có
save_folder = "charts/decomposition"
if not os.path.exists(save_folder):
    os.makedirs(save_folder)

saved_files = []

# Vẽ và lưu từng ảnh decomposition
for col in df.columns:
    series = df[col].dropna()
    if len(series) >= 48:
        try:
            result = seasonal_decompose(series, model='additive', period=24)
            fig = result.plot()
            fig.suptitle(f"Decomposition of {col}", y=1.02)

            # Đổi màu
            axes = fig.get_axes()
            axes[1].lines[0].set_color('red')
            axes[2].lines[0].set_color('green')
            axes[3].lines[0].set_color('orange')

            for ax in axes:
                ax.grid(True)

            plt.tight_layout()
            filename = os.path.join(save_folder, f"{col}_decomp.png")
            plt.savefig(filename, bbox_inches='tight')
            plt.close(fig)

            saved_files.append(filename)

        except Exception as e:
            print(f"⚠ Không thể decomposition biến {col}: {e}")
    else:
        print(f"⚠ Biến {col} không đủ dữ liệu.")

# Gộp tất cả ảnh decomposition nhỏ thành 1 ảnh lớn, 2 ảnh trên 1 hàng
if saved_files:
    images = [Image.open(f) for f in saved_files]

    widths, heights = zip(*(img.size for img in images))

    imgs_per_row = 2
    rows = math.ceil(len(images) / imgs_per_row)

    max_width = max(widths)
    max_height = max(heights)

    total_width = imgs_per_row * max_width
    total_height = rows * max_height

    combined_img = Image.new('RGB', (total_width, total_height), 'white')

    for idx, img in enumerate(images):
        row = idx // imgs_per_row
        col = idx % imgs_per_row
        x = col * max_width
        y = row * max_height
        combined_img.paste(img, (x, y))

    display(combined_img)

else:
    print("⚠ Không có ảnh nào để gộp và hiển thị.")

"""# **📚 5. KIỂM TRA TÍNH DỪNG (ADF TEST)**"""

for col in df.columns:
    series = df[col].dropna()
    if len(series) > 0:
        try:
            result = adfuller(series)
            print(f"\nVariable: {col}")
            print(f'ADF Statistic: {result[0]:.4f}')
            print(f'p-value: {result[1]:.4f}')
            print('Critical Values:')
            for key, value in result[4].items():
                print(f'   {key}: {value:.4f}')
            if result[1] > 0.05:
                print("=> Chuỗi không dừng (non-stationary)")
            else:
                print("=> Chuỗi dừng (stationary)")
        except Exception as e:
            print(f"⚠ Không thể kiểm tra ADF cho biến {col}: {e}")
    else:
        print(f"⚠ Biến {col} không có dữ liệu để kiểm tra ADF.")

"""# **📚 6. PHÉP SAI PHÂN (DIFFERENCING)**"""

import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
import math

print("\n\n=== PHÉP SAI PHÂN & VẼ BIỂU ĐỒ CHO TỪNG BIẾN (2004-03-15 đến 2004-03-20) ===")

start_date = "2004-03-15"
end_date = "2004-03-20"

time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

cols = df_period.columns.tolist()
n_vars = len(cols)

# Mỗi biến sẽ có 2 biểu đồ (chuỗi gốc + sai phân hoặc chỉ chuỗi gốc)
# 2 biến trên 1 hàng -> 4 biểu đồ trên mỗi hàng
plots_per_row = 4
vars_per_row = 2
n_rows = math.ceil(n_vars / vars_per_row)

fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(20, 5 * n_rows))
if n_rows == 1:
    axes = axes.reshape(1, -1)  # Đảm bảo axes là 2 chiều

def apply_differencing(series, order=1, seasonal_order=None, seasonal_period=24):
    diff_series = series.copy()
    for _ in range(order):
        diff_series = diff_series.diff().dropna()
    if seasonal_order is not None:
        for _ in range(seasonal_order):
            diff_series = diff_series.diff(seasonal_period).dropna()
    return diff_series

for idx, col in enumerate(cols):
    row = idx // vars_per_row
    col_pos = idx % vars_per_row

    ax_orig = axes[row, col_pos*2]       # Vị trí biểu đồ chuỗi gốc
    ax_diff = axes[row, col_pos*2 + 1]  # Vị trí biểu đồ sai phân

    try:
        series = df_period[col].dropna()
        result = adfuller(series)
        pvalue = result[1]

        if pvalue > 0.05:
            # Không dừng → áp dụng sai phân
            diff_series = apply_differencing(series, order=1)
            diff_series = diff_series[(diff_series.index >= start_date) & (diff_series.index <= end_date)]

            # Vẽ chuỗi gốc
            series.plot(ax=ax_orig, color='black')
            ax_orig.set_title(f"[{col}] Chuỗi gốc\n({start_date} đến {end_date})")
            ax_orig.grid(True)

            # Vẽ chuỗi sai phân
            if not diff_series.empty:
                diff_series.plot(ax=ax_diff, color='black')
                ax_diff.set_title(f"[{col}] Sai phân bậc 1\n({start_date} đến {end_date})")
                ax_diff.grid(True)
            else:
                ax_diff.text(0.5, 0.5, 'Không đủ dữ liệu\nsau sai phân',
                             ha='center', va='center', transform=ax_diff.transAxes)
                ax_diff.set_title(f"[{col}] Sai phân bậc 1\n({start_date} đến {end_date})")
                ax_diff.grid(False)
        else:
            # Đã dừng → chỉ vẽ chuỗi gốc ở cả 2 ô để giữ layout
            series.plot(ax=ax_orig, color='black')
            ax_orig.set_title(f"[{col}] Đã dừng (ADF p={pvalue:.4f})\n({start_date} đến {end_date})")
            ax_orig.grid(True)

            ax_diff.axis('off')  # Ẩn trục sai phân vì không có

    except Exception as e:
        ax_orig.text(0.5, 0.5, f'Lỗi với biến\n{col}\n{str(e)}', ha='center', va='center', transform=ax_orig.transAxes)
        ax_orig.set_title(f"[{col}] Lỗi")
        ax_diff.axis('off')

plt.tight_layout()
plt.show()

"""# **📚 7. VẼ ACF & PACF**"""

import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import math

cols = df.columns.tolist()
n_vars = len(cols)

vars_per_row = 2   # 2 biến trên mỗi hàng
plots_per_row = vars_per_row * 2  # mỗi biến 2 biểu đồ (ACF + PACF)
n_rows = math.ceil(n_vars / vars_per_row)

fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(16, 5 * n_rows))
if n_rows == 1:
    axes = axes.reshape(1, -1)  # Đảm bảo 2 chiều nếu chỉ 1 hàng

for idx, col in enumerate(cols):
    series = df[col].dropna()
    if len(series) < 50:
        print(f"⚠ Biến {col} không đủ dữ liệu để vẽ ACF/PACF.")
        # Ẩn 2 ô trống dành cho biến này
        row = idx // vars_per_row
        col_pos = idx % vars_per_row
        axes[row, col_pos*2].axis('off')
        axes[row, col_pos*2 + 1].axis('off')
        continue

    try:
        row = idx // vars_per_row
        col_pos = idx % vars_per_row

        ax_acf = axes[row, col_pos*2]
        ax_pacf = axes[row, col_pos*2 + 1]

        fig.suptitle(f"ACF và PACF các biến", fontsize=16, y=1.02)

        plot_acf(series, ax=ax_acf, lags=40, zero=False)
        ax_acf.set_title(f"ACF của {col}")

        plot_pacf(series, ax=ax_pacf, lags=40, method='ywmle', zero=False)
        ax_pacf.set_title(f"PACF của {col}")

    except Exception as e:
        print(f"⚠ Không thể vẽ ACF/PACF cho biến {col}: {e}")
        axes[row, col_pos*2].axis('off')
        axes[row, col_pos*2 + 1].axis('off')

# Ẩn các trống còn lại nếu có
total_plots = n_rows * plots_per_row
for i in range(n_vars, total_plots // 2):
    row = i // vars_per_row
    col_pos = i % vars_per_row
    axes[row, col_pos*2].axis('off')
    axes[row, col_pos*2 + 1].axis('off')

plt.tight_layout()
plt.show()

"""# **📚 8. MOVING AVERAGE (TRUNG BÌNH TRƯỢT 24h)**"""

import matplotlib.pyplot as plt
import math

# Các biến hợp lệ (đủ dữ liệu)
valid_cols = [col for col in df.columns if df[col].dropna().shape[0] >= 24]

# Thông số hiển thị
plots_per_row = 2
n_plots = len(valid_cols)
n_rows = math.ceil(n_plots / plots_per_row)

# Tạo figure lớn
fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(16, 5 * n_rows))

# Đảm bảo axes luôn là 2 chiều
if n_rows == 1:
    axes = axes.reshape(1, -1)

for idx, col in enumerate(valid_cols):
    row = idx // plots_per_row
    col_pos = idx % plots_per_row
    ax = axes[row, col_pos]

    try:
        df[col].plot(ax=ax, label='Original', alpha=0.5)
        df[col].rolling(window=24).mean().plot(ax=ax, label='24h Rolling Mean', linewidth=2)

        ax.set_title(f"{col}", fontsize=12)
        ax.legend()
        ax.grid(True)
    except Exception as e:
        print(f"⚠ Không thể vẽ Rolling Mean cho biến {col}: {e}")
        ax.axis('off')

# Ẩn các ô trống nếu số biến lẻ
if n_plots % plots_per_row != 0:
    for j in range(n_plots, n_rows * plots_per_row):
        row = j // plots_per_row
        col_pos = j % plots_per_row
        axes[row, col_pos].axis('off')

plt.suptitle("Moving Average (Trung bình trượt 24h)", fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

"""# **📚 9. EXPONENTIAL MOVING AVERAGE (EMA)**




"""

import matplotlib.pyplot as plt
import math

# Các biến hợp lệ (đủ dữ liệu)
valid_cols = [col for col in df.columns if df[col].dropna().shape[0] >= 24]

# Thông số hiển thị
plots_per_row = 2
n_plots = len(valid_cols)
n_rows = math.ceil(n_plots / plots_per_row)

# Tạo figure lớn
fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(16, 5 * n_rows))

# Đảm bảo axes luôn là 2 chiều
if n_rows == 1:
    axes = axes.reshape(1, -1)

for idx, col in enumerate(valid_cols):
    row = idx // plots_per_row
    col_pos = idx % plots_per_row
    ax = axes[row, col_pos]

    try:
        df[col].plot(ax=ax, label='Original', alpha=0.5)
        df[col].ewm(span=24).mean().plot(ax=ax, label='EMA (span=24)', linewidth=2, color='red')

        ax.set_title(f"{col}", fontsize=12)
        ax.legend()
        ax.grid(True)
    except Exception as e:
        print(f"⚠ Không thể vẽ EMA cho biến {col}: {e}")
        ax.axis('off')

# Ẩn ô trống nếu số biến lẻ
if n_plots % plots_per_row != 0:
    for j in range(n_plots, n_rows * plots_per_row):
        row = j // plots_per_row
        col_pos = j % plots_per_row
        axes[row, col_pos].axis('off')

plt.suptitle("Exponential Moving Average (EMA, span=24)", fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

"""# **📚 10. ĐO ĐỘ CHÍNH XÁC DỰ BÁO ( MAPE, MAE, MSE, RMSE)**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from sklearn.metrics import mean_absolute_error, mean_squared_error
from IPython.display import display, HTML
import base64
import math

# === 1. CHỌN KHOẢNG THỜI GIAN ĐÁNH GIÁ ===
start_date = "2004-03-15"
end_date = "2004-03-20"
df_eval = df.loc[start_date:end_date]
df_pred = df_eval.shift(1)  # Naive forecast

# === 2. HÀM TÍNH MAPE ===
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    mask = (y_true != 0) & (~np.isnan(y_true)) & (~np.isnan(y_pred))
    return np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100

# === 3. TÍNH TOÁN CHỈ SỐ VÀ LƯU KẾT QUẢ ===
results = []
os.makedirs("charts/forecast_line", exist_ok=True)
os.makedirs("charts/metrics", exist_ok=True)

for col in df.columns:
    try:
        y_true = df_eval[col]
        y_pred = df_pred[col]
        valid_idx = y_true.notna() & y_pred.notna()
        y_true_clean = y_true[valid_idx]
        y_pred_clean = y_pred[valid_idx]

        if len(y_true_clean) > 0:
            mae = mean_absolute_error(y_true_clean, y_pred_clean)
            mse = mean_squared_error(y_true_clean, y_pred_clean)
            rmse = np.sqrt(mse)
            mape = mean_absolute_percentage_error(y_true_clean, y_pred_clean)
            results.append({'Biến': col, 'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})
        else:
            print(f"⚠️ Biến {col} không đủ dữ liệu hợp lệ.")
    except Exception as e:
        print(f"❌ Lỗi với biến {col}: {e}")

# === 4. XỬ LÝ KẾT QUẢ ===
results_df = pd.DataFrame(results)

if not results_df.empty:
    results_df = results_df.sort_values(by="MAPE", ascending=False)
    display(results_df)
    results_df.to_csv("charts/metrics/evaluation_results.csv", index=False)

    # === 5. GỘP CÁC BIỂU ĐỒ DỰ BÁO VS THỰC TẾ ===
    num_vars = len(results_df)
    cols_subplot = 2
    rows_subplot = math.ceil(num_vars / cols_subplot)

    fig, axs = plt.subplots(rows_subplot, cols_subplot, figsize=(16, 5 * rows_subplot))
    axs = axs.flatten()

    for i, result in enumerate(results_df.itertuples()):
        col = result.Biến
        y_true = df_eval[col]
        y_pred = df_pred[col]
        valid_idx = y_true.notna() & y_pred.notna()
        y_true_clean = y_true[valid_idx]
        y_pred_clean = y_pred[valid_idx]

        axs[i].plot(y_true_clean.index, y_true_clean.values, label='Giá trị thực tế', color='black', linewidth=2)
        axs[i].plot(y_pred_clean.index, y_pred_clean.values, label='Dự báo (Naive)', color='orange', linestyle='--', linewidth=2)
        axs[i].set_title(f'{col}', fontsize=12)
        axs[i].set_xlabel('Thời gian')
        axs[i].set_ylabel('Giá trị')
        axs[i].legend()
        axs[i].grid(True)

    for j in range(i + 1, len(axs)):
        fig.delaxes(axs[j])

    plt.tight_layout()
    forecast_path = "charts/forecast_line/all_forecasts_combined.png"
    plt.savefig(forecast_path)
    plt.close()

    with open(forecast_path, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        display(HTML(f'<h3>Biểu đồ Dự báo vs Thực tế</h3><img src="data:image/png;base64,{img_data}" style="border:1px solid #ccc; width:1000px"/>'))

    # === 6. GỘP BIỂU ĐỒ CHỈ SỐ MAE, MSE, RMSE, MAPE ===
    fig, axs = plt.subplots(2, 2, figsize=(14, 10))
    axs = axs.flatten()
    metrics = ['MAE', 'MSE', 'RMSE', 'MAPE']
    colors = ['gold', 'royalblue', 'seagreen', 'tomato']

    for i, metric in enumerate(metrics):
        axs[i].barh(results_df['Biến'], results_df[metric], color=colors[i])
        axs[i].set_title(f'{metric} theo biến ({start_date} - {end_date})')
        axs[i].set_xlabel(metric)
        axs[i].invert_yaxis()
        axs[i].grid(True)

    plt.tight_layout()
    metric_path = "charts/metrics/all_metrics_combined.png"
    plt.savefig(metric_path)
    plt.close()

    with open(metric_path, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        display(HTML(f'<h3>Biểu đồ các chỉ số đánh giá</h3><img src="data:image/png;base64,{img_data}" style="border:1px solid #ccc; width:1000px"/>'))

else:
    print("❌ Không có kết quả nào sau khi xử lý NaN.")

from google.colab import sheets
sheet = sheets.InteractiveSheet(df=results_df)

"""# **📚 11. XÁC NHẬN CHÉO (CROSS-VALIDATION) TRONG DỰ BÁO CHUỖI THỜI GIAN**

## **📚📚 11.1 Bảng so sánh hiệu suất dự báo**
"""

from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np
import pandas as pd

# ==== Hàm tính MAPE ====
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    mask = (y_true != 0) & (~np.isnan(y_true)) & (~np.isnan(y_pred))
    return np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100

# ==== Hàm dự báo ngây thơ ====
def naive_forecast(train, horizon):
    return [train.iloc[-1]] * horizon

# ==== Cross-validation: Expanding Window ====
def expanding_window_cv(series, forecast_func, initial_train_size, horizon, step=1):
    metrics = []
    for start in range(initial_train_size, len(series) - horizon, step):
        train = series[:start]
        test = series[start:start+horizon]
        pred = forecast_func(train, horizon)
        test = test.values
        pred = np.array(pred)

        mae = mean_absolute_error(test, pred)
        mse = mean_squared_error(test, pred)
        rmse = np.sqrt(mse)
        mape = mean_absolute_percentage_error(test, pred)
        metrics.append({'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})

    return pd.DataFrame(metrics).mean()

# ==== Cross-validation: Rolling Window ====
def rolling_window_cv(series, forecast_func, train_size, horizon, step=1):
    metrics = []
    for start in range(0, len(series) - train_size - horizon, step):
        train = series[start:start+train_size]
        test = series[start+train_size:start+train_size+horizon]
        pred = forecast_func(train, horizon)
        test = test.values
        pred = np.array(pred)

        mae = mean_absolute_error(test, pred)
        mse = mean_squared_error(test, pred)
        rmse = np.sqrt(mse)
        mape = mean_absolute_percentage_error(test, pred)
        metrics.append({'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})

    return pd.DataFrame(metrics).mean()

# ==== Thiết lập khung thời gian ====
start_date = "2004-03-15"
end_date = "2004-03-20"
df_eval = df.loc[start_date:end_date]

# ==== Cấu hình ====
initial_train_size = 24  # tối thiểu 1 ngày (vì dữ liệu theo giờ)
horizon = 5
step = 1

# ==== Kết quả tổng hợp ====
expanding_results = []
rolling_results = []

for col in df_eval.columns:
    series = df_eval[col].dropna()
    if len(series) >= initial_train_size + horizon + 5:
        try:
            expanding_avg = expanding_window_cv(series, naive_forecast, initial_train_size, horizon, step)
            rolling_avg = rolling_window_cv(series, naive_forecast, initial_train_size, horizon, step)

            expanding_results.append({
                'Biến': col,
                'MAE': expanding_avg['MAE'],
                'MSE': expanding_avg['MSE'],
                'RMSE': expanding_avg['RMSE'],
                'MAPE': expanding_avg['MAPE'],
                'Phương pháp': 'Expanding'
            })
            rolling_results.append({
                'Biến': col,
                'MAE': rolling_avg['MAE'],
                'MSE': rolling_avg['MSE'],
                'RMSE': rolling_avg['RMSE'],
                'MAPE': rolling_avg['MAPE'],
                'Phương pháp': 'Rolling'
            })
        except Exception as e:
            print(f"❌ Lỗi với biến {col}: {e}")
    else:
        print(f"⚠️ Biến {col} không đủ dữ liệu để CV (len={len(series)})")

# ==== Ghép và hiển thị kết quả ====
cv_results_df = pd.DataFrame(expanding_results + rolling_results)
display(cv_results_df.sort_values(by=["Biến", "Phương pháp"]))

"""## **📚📚 11.2 Biểu đồ Cross- validation**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# Tạo thư mục lưu ảnh
chart_dir = "charts/ema/cv"
os.makedirs(chart_dir, exist_ok=True)

# Các thông số chung
initial_train_size = 24
horizon = 5
step = 1

image_tags = []

# Hàm vẽ biểu đồ Expanding hoặc Rolling cho một độ dài chuỗi nhất định
def plot_cv_schedule(series_len, train_size, horizon, step, mode="expanding"):
    if mode == "expanding":
        split_points = list(range(train_size, series_len - horizon, step))
        title = "Expanding Window CV"
        filename = os.path.join(chart_dir, "all_expanding.png")
    else:  # rolling
        split_points = list(range(0, series_len - train_size - horizon, step))
        title = "Rolling Window CV"
        filename = os.path.join(chart_dir, "all_rolling.png")

    n_splits = len(split_points)
    fig, ax = plt.subplots(figsize=(12, 6))

    for idx, start in enumerate(split_points):
        if mode == "expanding":
            train_start, train_end = 0, start
            test_start, test_end = start, start + horizon
        else:
            train_start, train_end = start, start + train_size
            test_start, test_end = train_end, train_end + horizon

        ax.plot(range(train_start, train_end), [idx] * (train_end - train_start),
                marker='o', linestyle='None', color='blue', label='Training' if idx == 0 else "")
        ax.plot(range(test_start, test_end), [idx] * (test_end - test_start),
                marker='s', linestyle='None', color='red', label='Test' if idx == 0 else "")
        ax.annotate('', xy=(series_len-0.5, idx), xytext=(-0.5, idx),
                    arrowprops=dict(arrowstyle="->", color='gray', lw=1))

    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_xlabel("Chỉ số quan sát theo thời gian")
    ax.set_ylabel("Lần kiểm thử")
    ax.set_yticks(range(n_splits))
    ax.set_xlim(-0.5, series_len - 0.5)
    ax.grid(True, linestyle='--', alpha=0.4)
    ax.legend(loc='upper right')

    plt.tight_layout()
    plt.savefig(filename)
    plt.close(fig)

    # Thêm hình vào danh sách HTML
    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right:30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# Tìm một chuỗi có đủ dữ liệu để đại diện
for col in df_eval.columns:
    series = df_eval[col].dropna()
    if len(series) >= initial_train_size + horizon + 5:
        series_len = len(series)
        plot_cv_schedule(series_len, initial_train_size, horizon, step, mode="expanding")
        plot_cv_schedule(series_len, initial_train_size, horizon, step, mode="rolling")
        break  # chỉ lấy một biến đầu tiên đủ điều kiện

# Hiển thị HTML
html_code = '<div style="display: flex; flex-wrap: nowrap; overflow-x: auto;">' + ''.join(image_tags) + '</div>'
display(HTML(html_code))

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Chuẩn bị dữ liệu
cv_metrics = cv_results_df.melt(
    id_vars=['Biến', 'Phương pháp'],
    value_vars=['MAE', 'MAPE', 'RMSE'],
    var_name='Chỉ số',
    value_name='Giá trị'
)

# Màu sắc
colors = ['#1f77b4', '#ff7f0e', '#2ca02c']  # Xanh, Cam, Xanh lá

# ===== BIỂU ĐỒ EXPANDING =====
fig1, axes1 = plt.subplots(1, 3, figsize=(18, 6))
plt.subplots_adjust(wspace=0.3)

expanding_data = cv_metrics[cv_metrics['Phương pháp'] == 'Expanding']

for idx, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
    ax = axes1[idx]
    subset = expanding_data[expanding_data['Chỉ số'] == metric]

    # Vẽ line plot với markers
    ax.plot(subset['Biến'], subset['Giá trị'],
            color=colors[idx], linewidth=3, marker='o',
            markersize=8, markerfacecolor='white',
            markeredgecolor=colors[idx], markeredgewidth=2)

    ax.set_title(f'{metric} - Expanding Window', fontsize=14, fontweight='bold')
    ax.set_xlabel("Biến số", fontsize=12)
    ax.set_ylabel("Giá trị", fontsize=12)
    ax.tick_params(axis='x', rotation=45)
    ax.grid(True, alpha=0.3)

    # Tô màu nền cho các giá trị cao
    if len(subset) > 0:
        max_val = subset['Giá trị'].max()
        min_val = subset['Giá trị'].min()
        ax.axhspan(min_val, max_val * 0.3, alpha=0.1, color=colors[idx])

fig1.suptitle("Expanding Window Cross-Validation Results",
              fontsize=16, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# ===== BIỂU ĐỒ ROLLING =====
fig2, axes2 = plt.subplots(1, 3, figsize=(18, 6))
plt.subplots_adjust(wspace=0.3)

rolling_data = cv_metrics[cv_metrics['Phương pháp'] == 'Rolling']

for idx, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
    ax = axes2[idx]
    subset = rolling_data[rolling_data['Chỉ số'] == metric]

    # Vẽ line plot với markers
    ax.plot(subset['Biến'], subset['Giá trị'],
            color=colors[idx], linewidth=3, marker='s',
            markersize=8, markerfacecolor='white',
            markeredgecolor=colors[idx], markeredgewidth=2)

    ax.set_title(f'{metric} - Rolling Window', fontsize=14, fontweight='bold')
    ax.set_xlabel("Biến số", fontsize=12)
    ax.set_ylabel("Giá trị", fontsize=12)
    ax.tick_params(axis='x', rotation=45)
    ax.grid(True, alpha=0.3)

    # Tô màu nền cho các giá trị cao
    if len(subset) > 0:
        max_val = subset['Giá trị'].max()
        min_val = subset['Giá trị'].min()
        ax.axhspan(min_val, max_val * 0.3, alpha=0.1, color=colors[idx])

fig2.suptitle("Rolling Window Cross-Validation Results",
              fontsize=16, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# ===== PHIÊN BẢN ĐƠN GIẢN HỚN =====
# Nếu muốn style đơn giản hơn
def plot_simple_version(method_name, data, fig_title):
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    method_data = data[data['Phương pháp'] == method_name]

    for i, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
        subset = method_data[method_data['Chỉ số'] == metric]

        axes[i].plot(subset['Biến'], subset['Giá trị'],
                    'o-', linewidth=2, markersize=6)
        axes[i].set_title(metric)
        axes[i].set_xlabel('Biến số')
        axes[i].set_ylabel('Giá trị')
        axes[i].tick_params(axis='x', rotation=45)
        axes[i].grid(True, alpha=0.3)

    plt.suptitle(fig_title, fontsize=14, fontweight='bold')
    plt.tight_layout()
    plt.show()

# Gọi hàm để vẽ
print("=== EXPANDING WINDOW ===")
plot_simple_version('Expanding', cv_metrics, 'Expanding Window Results')

print("\n=== ROLLING WINDOW ===")
plot_simple_version('Rolling', cv_metrics, 'Rolling Window Results')

# Kiểm tra dữ liệu
print("\n=== THÔNG TIN DỮ LIỆU ===")
print("Phương pháp có sẵn:", cv_metrics['Phương pháp'].unique())
print("Số điểm dữ liệu Expanding:", len(cv_metrics[cv_metrics['Phương pháp'] == 'Expanding']))
print("Số điểm dữ liệu Rolling:", len(cv_metrics[cv_metrics['Phương pháp'] == 'Rolling']))

"""## **📚📚 11.3 Lưu kết quả Cross- validation**"""

# Lưu kết quả cross-validation
cv_results_df.to_csv('cross_validation_results.csv', index=False)

# Lưu kết quả đánh giá mô hình naive
results_df.to_csv('naive_forecast_evaluation.csv', index=False)

"""# **📚 12. MÔ HÌNH ARIMA**"""

# ================ MÔ HÌNH ARIMA ================
print("\n\n=== MÔ HÌNH ARIMA (2004-03-15 đến 2004-03-20) ===")

from statsmodels.tsa.arima.model import ARIMA

# Chọn khoảng thời gian mong muốn
start_date = '2004-03-15'
end_date = '2004-03-20'
time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

# Hàm xây dựng mô hình ARIMA
def fit_arima(series, order=(1, 1, 1)):
    """Fit mô hình ARIMA với các tham số cho trước"""
    model = ARIMA(series, order=order)
    fitted_model = model.fit()
    return fitted_model

# Áp dụng cho 3 biến đầu tiên để demo
for col in df_period.columns[:3]:
    try:
        print(f"\nĐang xây dựng mô hình ARIMA cho {col}...")
        series = df_period[col].dropna()

        if len(series) >= 30:  # Đảm bảo đủ dữ liệu
            model = fit_arima(series, order=(1, 1, 1))
            print(model.summary())

            # Dự báo 12 giờ tiếp theo
            forecast = model.forecast(steps=12)

            # Vẽ đồ thị
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(series.index, series, label='Thực tế')
            ax.plot(pd.date_range(series.index[-1], periods=13, freq='h')[1:],
                    forecast, label='Dự báo', color='red', marker='o')
            ax.set_title(f'Dự báo ARIMA cho {col} (2004-03-15 đến 2004-03-20)')
            ax.legend()
            plt.grid(True)
            plt.show()
        else:
            print(f"Không đủ dữ liệu cho {col} để xây dựng mô hình ARIMA (chỉ có {len(series)} quan sát)")

    except Exception as e:
        print(f"Lỗi khi xây dựng ARIMA cho {col}: {str(e)}")

"""# **📚 13. MÔ HÌNH HOLT-WINTERS**"""

# ================ MÔ HÌNH HOLT-WINTERS (2004-03-15 đến 2004-03-20) ================
print("\n\n=== MÔ HÌNH HOLT-WINTERS CHO KHOẢNG THỜI GIAN 2004-03-15 ĐẾN 2004-03-20 ===")

from statsmodels.tsa.holtwinters import ExponentialSmoothing

def fit_holt_winters(series, seasonal_periods=24, trend='add', seasonal='add'):
    """Xây dựng mô hình Holt-Winters"""
    model = ExponentialSmoothing(series,
                               trend=trend,
                               seasonal=seasonal,
                               seasonal_periods=seasonal_periods)
    return model.fit()

# Lọc dữ liệu chỉ trong khoảng thời gian mong muốn
time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

# Áp dụng cho các biến có tính thời vụ
for col in ['PT08.S1(CO)', 'T', 'RH']:  # Chọn 3 biến có tính thời vụ rõ
    try:
        print(f"\nĐang xây dựng mô hình Holt-Winters cho {col}...")
        series = df_period[col].dropna()

        if len(series) >= 24:  # Cần ít nhất 1 chu kỳ mùa
            # Fit model
            model = fit_holt_winters(series)
            print(model.summary())

            # Dự báo 12 giờ tiếp theo
            forecast = model.forecast(12)

            # Vẽ đồ thị
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(series.index, series, label='Thực tế', color='black', linewidth=2)
            ax.plot(pd.date_range(series.index[-1], periods=13, freq='H')[1:],
                    forecast, label='Dự báo', color='red', linestyle='--', linewidth=2)
            ax.set_title(f'Dự báo Holt-Winters cho {col}\n({start_date} đến {end_date})')
            ax.set_xlabel('Thời gian')
            ax.set_ylabel('Giá trị')
            ax.legend()
            ax.grid(True)
            plt.tight_layout()
            plt.show()
        else:
            print(f"Không đủ dữ liệu cho {col} (chỉ có {len(series)} quan sát)")
    except Exception as e:
        print(f"Lỗi khi xây dựng Holt-Winters cho {col}: {str(e)}")

"""# **📚 14. KIỂM TRA PHẦN DƯ**"""

from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.stats.diagnostic import acorr_ljungbox
import seaborn as sns
import matplotlib.pyplot as plt
import math

# Danh sách lưu trữ phần dư và tiêu đề
residuals_list = []
titles = []

# Bước 1: Fit ARIMA và lưu phần dư
for col in df.columns:
    try:
        series = df[col].dropna()
        model = ARIMA(series, order=(1,1,1)).fit()
        residuals_list.append(model.resid)
        titles.append(col)
        print(f"✅ Hoàn tất ARIMA cho {col}")
    except Exception as e:
        print(f"❌ Lỗi khi xử lý {col}: {e}")

# Bước 2: Tạo ảnh gộp ACF và Histogram (2 cột mỗi biến, 2 biến mỗi hàng)
plots_per_row = 2
plots_per_block = 2  # ACF và Histogram
total_plots = len(residuals_list) * plots_per_block
n_rows = math.ceil(total_plots / plots_per_row)

fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(16, 4 * n_rows))
if n_rows == 1:
    axes = axes.reshape(1, -1)

plot_idx = 0
for resid, title in zip(residuals_list, titles):
    # ACF plot
    row = plot_idx // plots_per_row
    col = plot_idx % plots_per_row
    ax = axes[row, col]
    plot_acf(resid.dropna(), ax=ax, lags=40)
    ax.set_title(f'ACF phần dư - {title}')
    plot_idx += 1

    # Histogram plot
    row = plot_idx // plots_per_row
    col = plot_idx % plots_per_row
    ax = axes[row, col]
    sns.histplot(resid.dropna(), kde=True, ax=ax)
    ax.set_title(f'Phân phối phần dư - {title}')
    plot_idx += 1

# Ẩn ô trống nếu số lượng biểu đồ không chia hết
for i in range(plot_idx, n_rows * plots_per_row):
    row = i // plots_per_row
    col = i % plots_per_row
    axes[row, col].axis('off')

plt.tight_layout()
os.makedirs("charts/residuals", exist_ok=True)
plt.savefig("charts/residuals/all_residuals_diagnostics.png", bbox_inches='tight')
plt.show()