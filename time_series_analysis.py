# -*- coding: utf-8 -*-
"""Time series analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UZsPzKHtn2PK5ZCL9mvmJefoL3KqkZbH

# **üìö 1. IMPORT TH∆Ø VI·ªÜN C·∫¶N THI·∫æT**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.metrics import mean_squared_error

# C√†i ƒë·∫∑t chung cho matplotlib v√† seaborn
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)

"""# **üìö 2. ƒê·ªåC D·ªÆ LI·ªÜU V√Ä X·ª¨ L√ç D·ªÆ LI·ªÜU**"""

# ƒê·ªçc d·ªØ li·ªáu t·ª´ URL
DATA_PATH = "https://redcap.huph.edu.vn/ddp/tsa/nhom4.csv"
df = pd.read_csv(DATA_PATH, sep=',', decimal='.', na_values=-200)

# Ch·ªçn c√°c c·ªôt c·∫ßn thi·∫øt
cols = ['Date', 'Time', 'CO(GT)', 'PT08.S1(CO)', 'NMHC(GT)', 'C6H6(GT)',
        'PT08.S2(NMHC)', 'NOx(GT)', 'PT08.S3(NOx)', 'NO2(GT)',
        'PT08.S4(NO2)', 'PT08.S5(O3)', 'T', 'RH', 'AH']
df = df[cols]

# Chuy·ªÉn ƒë·ªïi sang datetime v√† ƒë·∫∑t l√†m index
df['Timestamp'] = pd.to_datetime(df['Date'] + ' ' + df['Time'])
df = df.drop(columns=['Date', 'Time']).set_index('Timestamp')

# X·ª≠ l√Ω gi√° tr·ªã thi·∫øu
df = df.dropna()

# Hi·ªÉn th·ªã th√¥ng tin c∆° b·∫£n
print("Shape:", df.shape)
print("\nInfo:")
print(df.info())
print("\n5 d√≤ng ƒë·∫ßu ti√™n:")
print(df.head())

"""# **üìö 3. PLOT D·ªÆ LI·ªÜU TH√î**

## **üìöüìö 3.1 Plot ch·∫•t d·ªØ li·ªáu √¥ nhi·ªÖm**
"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh
if not os.path.exists("charts"):
    os.makedirs("charts")

pollutants = ['CO(GT)', 'NMHC(GT)', 'C6H6(GT)', 'NOx(GT)', 'NO2(GT)']
image_tags = []

for col in pollutants:
    fig, ax = plt.subplots(figsize=(10, 5))  # üëâ K√≠ch th∆∞·ªõc l·ªõn h∆°n (ngang 10 inch)
    ax.plot(df.index, df[col], linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel('Concentration')
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')  # üëâ L∆∞u g·ªçn s√°t n·ªôi dung
    plt.close(fig)

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        # üëâ ·∫¢nh hi·ªÉn th·ªã r·ªông h∆°n: 700px
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# üëâ HTML x·∫øp ·∫£nh ngang, cu·ªôn ngang ƒë∆∞·ª£c
html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""## **üìöüìö 3.2 Plot th·ªùi ti·∫øt**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh n·∫øu ch∆∞a c√≥
if not os.path.exists("charts"):
    os.makedirs("charts")

meteo = ['T', 'RH', 'AH']
image_tags = []

for col in meteo:
    fig, ax = plt.subplots(figsize=(10, 5))  # K√≠ch th∆∞·ªõc ·∫£nh ngang 10 inch, cao 5 inch
    ax.plot(df.index, df[col], color='orange', linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel(col)
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')  # L∆∞u ·∫£nh g·ªçn s√°t n·ªôi dung
    plt.close(fig)  # ƒê√≥ng ·∫£nh ƒë·ªÉ tr√°nh t·ªën b·ªô nh·ªõ

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# T·∫°o HTML ƒë·ªÉ hi·ªÉn th·ªã ·∫£nh theo h√†ng ngang v√† c√≥ th·ªÉ cu·ªôn ngang
html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""## **üìöüìö 3.3 Plot sensor**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh n·∫øu ch∆∞a c√≥
if not os.path.exists("charts"):
    os.makedirs("charts")

sensors = ['PT08.S1(CO)', 'PT08.S2(NMHC)', 'PT08.S3(NOx)', 'PT08.S4(NO2)', 'PT08.S5(O3)']
image_tags = []

for col in sensors:
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(df.index, df[col], color='green', linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel(col)
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')
    plt.close(fig)

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""# **üìö 4. PH√ÇN T√çCH TH√ÄNH PH·∫¶N M√ôA V·ª§ (SEASONAL DECOMPOSITION)**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64
from statsmodels.tsa.seasonal import seasonal_decompose

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh decomposition n·∫øu ch∆∞a c√≥
if not os.path.exists("charts/decomposition"):
    os.makedirs("charts/decomposition")

image_tags = []

for col in df.columns:
    series = df[col].dropna()
    if len(series) >= 48:  # ƒê·∫£m b·∫£o ƒë·ªß d·ªØ li·ªáu cho decomposition
        try:
            result = seasonal_decompose(series, model='additive', period=24)

            # V·∫Ω decomposition m·∫∑c ƒë·ªãnh
            fig = result.plot()
            fig.suptitle(f"Decomposition of {col}", y=1.02)

            # L·∫•y axes (4 tr·ª•c)
            axes = fig.get_axes()

            # Gi·ªØ m√†u observed m·∫∑c ƒë·ªãnh (th∆∞·ªùng l√† xanh d∆∞∆°ng), ƒë·ªïi m√†u c√°c line sau
            # trend -> ƒë·ªè
            axes[1].lines[0].set_color('red')
            # seasonal -> xanh l√°
            axes[2].lines[0].set_color('green')
            # residual -> cam
            axes[3].lines[0].set_color('orange')

            # Th√™m grid cho r√µ h∆°n (tu·ª≥ ch·ªçn)
            for ax in axes:
                ax.grid(True)

            plt.tight_layout()

            # L∆∞u file
            filename = f"charts/decomposition/{col}_decomp.png"
            plt.savefig(filename, bbox_inches='tight')
            plt.close(fig)

            # M√£ h√≥a ·∫£nh ƒë·ªÉ hi·ªÉn th·ªã trong HTML
            with open(filename, "rb") as f:
                img_data = base64.b64encode(f.read()).decode("utf-8")
                img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
                image_tags.append(img_tag)

        except Exception as e:
            print(f"‚ö† Kh√¥ng th·ªÉ decomposition bi·∫øn {col}: {e}")
    else:
        print(f"‚ö† Bi·∫øn {col} kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ decomposition (√≠t h∆°n 48 quan s√°t).")

# Hi·ªÉn th·ªã t·∫•t c·∫£ ·∫£nh decomposition theo h√†ng ngang c√≥ th·ªÉ cu·ªôn ngang
html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""# **üìö 5. KI·ªÇM TRA T√çNH D·ª™NG (ADF TEST)**"""

for col in df.columns:
    series = df[col].dropna()
    if len(series) > 0:
        try:
            result = adfuller(series)
            print(f"\nVariable: {col}")
            print(f'ADF Statistic: {result[0]:.4f}')
            print(f'p-value: {result[1]:.4f}')
            print('Critical Values:')
            for key, value in result[4].items():
                print(f'   {key}: {value:.4f}')
            if result[1] > 0.05:
                print("=> Chu·ªói kh√¥ng d·ª´ng (non-stationary)")
            else:
                print("=> Chu·ªói d·ª´ng (stationary)")
        except Exception as e:
            print(f"‚ö† Kh√¥ng th·ªÉ ki·ªÉm tra ADF cho bi·∫øn {col}: {e}")
    else:
        print(f"‚ö† Bi·∫øn {col} kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ ki·ªÉm tra ADF.")

"""# **üìö 6. PH√âP SAI PH√ÇN (DIFFERENCING)**"""

print("\n\n=== PH√âP SAI PH√ÇN & V·∫º BI·ªÇU ƒê·ªí CHO T·ª™NG BI·∫æN (2004-03-15 ƒë·∫øn 2004-03-20) ===")

def apply_differencing(series, order=1, seasonal_order=None, seasonal_period=24):
    """√Åp d·ª•ng sai ph√¢n th∆∞·ªùng v√† sai ph√¢n th·ªùi v·ª• n·∫øu c·∫ßn"""
    diff_series = series.copy()
    for _ in range(order):
        diff_series = diff_series.diff().dropna()
    if seasonal_order is not None:
        for _ in range(seasonal_order):
            diff_series = diff_series.diff(seasonal_period).dropna()
    return diff_series

# L·ªçc d·ªØ li·ªáu trong kho·∫£ng th·ªùi gian mong mu·ªën
time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

for col in df_period.columns:
    try:
        series = df_period[col].dropna()

        # Ki·ªÉm tra t√≠nh d·ª´ng ban ƒë·∫ßu
        result = adfuller(series)
        pvalue = result[1]

        print(f"\nBi·∫øn {col} ", end='')
        if pvalue > 0.05:
            print(f"**kh√¥ng d·ª´ng**, p-value: {pvalue:.4f} ‚Üí √°p d·ª•ng sai ph√¢n...")
            diff_series = apply_differencing(series, order=1)
            diff_series = diff_series[(diff_series.index >= start_date) & (diff_series.index <= end_date)]

            # Ki·ªÉm tra l·∫°i t√≠nh d·ª´ng sau sai ph√¢n
            result_diff = adfuller(diff_series.dropna())
            print(f"ADF sau sai ph√¢n: {result_diff[0]:.4f}, p-value: {result_diff[1]:.4f}")

            # V·∫Ω c·∫£ chu·ªói g·ªëc v√† chu·ªói sai ph√¢n (line m√†u ƒëen)
            fig, axes = plt.subplots(2, 1, figsize=(12, 6))
            series.plot(ax=axes[0], title=f"[{col}] Chu·ªói g·ªëc ({start_date} ƒë·∫øn {end_date})", color='black')
            if not diff_series.empty:
                diff_series.plot(ax=axes[1], title=f"[{col}] Sau sai ph√¢n b·∫≠c 1 ({start_date} ƒë·∫øn {end_date})", color='black')
            else:
                axes[1].text(0.5, 0.5, 'Kh√¥ng ƒë·ªß d·ªØ li·ªáu sau sai ph√¢n',
                            ha='center', va='center', transform=axes[1].transAxes)
            plt.tight_layout()
            plt.show()

        else:
            print(f"**ƒë√£ d·ª´ng**, p-value: {pvalue:.4f}")
            # V·∫Ω bi·ªÉu ƒë·ªì chu·ªói g·ªëc (line m√†u ƒëen)
            plt.figure(figsize=(12, 4))
            series.plot(title=f"[{col}] ƒê√£ d·ª´ng (ADF p-value: {pvalue:.4f})\n{start_date} ƒë·∫øn {end_date}", color='black')
            plt.grid(True)
            plt.tight_layout()
            plt.show()

    except Exception as e:
        print(f"L·ªói v·ªõi bi·∫øn {col}: {str(e)}")

"""# **üìö 7. V·∫º ACF & PACF**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh ACF_PACF n·∫øu ch∆∞a c√≥
if not os.path.exists("charts/acf_pacf"):
    os.makedirs("charts/acf_pacf")

image_tags = []


for col in df.columns:
    series = df[col].dropna()
    if len(series) >= 50:  # ƒê·∫£m b·∫£o ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ v·∫Ω ACF, PACF
        try:
            fig, axes = plt.subplots(1, 2, figsize=(16, 6))

            fig.suptitle(f"ACF and PACF for {col}", y=1.05)

            plot_acf(series, ax=axes[0], lags=40)
            plot_pacf(series, ax=axes[1], lags=40, method='ywmle')

            plt.tight_layout(rect=[0, 0, 1, 0.95])  # Gi·ªØ ch·ªó cho ti√™u ƒë·ªÅ

            filename = f"charts/acf_pacf/{col}_acf_pacf.png"
            plt.savefig(filename, bbox_inches='tight')
            plt.close(fig)

            with open(filename, "rb") as f:
                img_data = base64.b64encode(f.read()).decode("utf-8")
                img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 750px"/>'
                image_tags.append(img_tag)

        except Exception as e:
            print(f"‚ö† Kh√¥ng th·ªÉ v·∫Ω ACF/PACF cho bi·∫øn {col}: {e}")
    else:
        print(f"‚ö† Bi·∫øn {col} kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ v·∫Ω ACF/PACF.")

html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""# **üìö 8. MOVING AVERAGE (TRUNG B√åNH TR∆Ø·ª¢T 24h)**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh n·∫øu ch∆∞a c√≥
if not os.path.exists("charts/rolling_mean"):
    os.makedirs("charts/rolling_mean")

image_tags = []

for col in df.columns:
    try:
        fig, ax = plt.subplots(figsize=(12, 5))
        df[col].plot(ax=ax, label='Original', alpha=0.5)
        df[col].rolling(window=24).mean().plot(ax=ax, label='24h Rolling Mean', linewidth=2)
        ax.set_title(f"Original vs 24h Moving Average - {col}")
        ax.legend()

        filename = f"charts/rolling_mean/{col}_rolling_mean.png"
        plt.savefig(filename, bbox_inches='tight')
        plt.close(fig)

        with open(filename, "rb") as f:
            img_data = base64.b64encode(f.read()).decode("utf-8")
            img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
            image_tags.append(img_tag)
    except Exception as e:
        print(f"‚ö† Kh√¥ng th·ªÉ v·∫Ω Rolling Mean cho bi·∫øn {col}: {e}")

html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""# **üìö 9. EXPONENTIAL MOVING AVERAGE (EMA)**




"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh n·∫øu ch∆∞a c√≥
if not os.path.exists("charts/ema"):
    os.makedirs("charts/ema")

image_tags = []

for col in df.columns:
    try:
        fig, ax = plt.subplots(figsize=(12, 5))
        df[col].plot(ax=ax, label='Original', alpha=0.5)
        df[col].ewm(span=24).mean().plot(ax=ax, label='EMA (span=24)', linewidth=2, color='red')
        ax.set_title(f"Original vs EMA - {col}")
        ax.legend()

        filename = f"charts/ema/{col}_ema.png"
        plt.savefig(filename, bbox_inches='tight')
        plt.close(fig)

        with open(filename, "rb") as f:
            img_data = base64.b64encode(f.read()).decode("utf-8")
            img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
            image_tags.append(img_tag)
    except Exception as e:
        print(f"‚ö† Kh√¥ng th·ªÉ v·∫Ω EMA cho bi·∫øn {col}: {e}")

html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""# **üìö 10. ƒêO ƒê·ªò CH√çNH X√ÅC D·ª∞ B√ÅO ( MAPE, MAE, MSE, RMSE)**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from sklearn.metrics import mean_absolute_error, mean_squared_error
from IPython.display import display, HTML
import base64

# 1. Ch·ªçn kho·∫£ng th·ªùi gian ƒë√°nh gi√°
start_date = "2004-03-15"
end_date = "2004-03-20"
df_eval = df.loc[start_date:end_date]
df_pred = df_eval.shift(1)  # Naive forecast

# 2. H√†m t√≠nh MAPE
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    mask = (y_true != 0) & (~np.isnan(y_true)) & (~np.isnan(y_pred))
    return np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100

# 3. T√≠nh ƒë·ªô ch√≠nh x√°c cho t·ª´ng bi·∫øn v√† v·∫Ω bi·ªÉu ƒë·ªì
results = []
forecast_image_tags = []
os.makedirs("charts/forecast_line", exist_ok=True)

for col in df.columns:
    try:
        y_true = df_eval[col]
        y_pred = df_pred[col]

        valid_idx = y_true.notna() & y_pred.notna()
        y_true_clean = y_true[valid_idx]
        y_pred_clean = y_pred[valid_idx]

        if len(y_true_clean) > 0:
            mae = mean_absolute_error(y_true_clean, y_pred_clean)
            mse = mean_squared_error(y_true_clean, y_pred_clean)
            rmse = np.sqrt(mse)
            mape = mean_absolute_percentage_error(y_true_clean, y_pred_clean)
            results.append({'Bi·∫øn': col, 'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})

            # V·∫Ω bi·ªÉu ƒë·ªì nh∆∞ trong slide
            fig, ax = plt.subplots(figsize=(14, 6))
            ax.plot(y_true_clean.index, y_true_clean.values, label='Gi√° tr·ªã th·ª±c t·∫ø', color='black', linewidth=2)
            ax.plot(y_pred_clean.index, y_pred_clean.values, label='D·ª± b√°o (Naive)', color='orange', linestyle='--', linewidth=2)
            ax.set_title(f'D·ª± b√°o vs Th·ª±c t·∫ø - {col}')
            ax.set_xlabel('Th·ªùi gian')
            ax.set_ylabel('Gi√° tr·ªã')
            ax.legend()
            ax.grid(True)
            plt.tight_layout()

            img_path = f"charts/forecast_line/{col}_forecast_vs_actual.png"
            plt.savefig(img_path)
            plt.close()

            with open(img_path, "rb") as f:
                img_data = base64.b64encode(f.read()).decode("utf-8")
                img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
                forecast_image_tags.append(img_tag)
        else:
            print(f"‚ö†Ô∏è Bi·∫øn {col} kh√¥ng ƒë·ªß d·ªØ li·ªáu h·ª£p l·ªá.")
    except Exception as e:
        print(f"‚ùå L·ªói v·ªõi bi·∫øn {col}: {e}")

# 4. T·∫°o b·∫£ng k·∫øt qu·∫£
results_df = pd.DataFrame(results)

if not results_df.empty:
    results_df = results_df.sort_values(by="MAPE", ascending=False)
    display(results_df)

    # L∆∞u b·∫£ng ra CSV
    os.makedirs("charts/metrics", exist_ok=True)
    results_df.to_csv("charts/metrics/evaluation_results.csv", index=False)

    # === V·∫º V√Ä L∆ØU RI√äNG T·ª™NG BI·ªÇU ƒê·ªí: MAE, MSE, RMSE, MAPE V·ªöI M√ÄU KH√ÅC NHAU ===
    metric_image_tags = []
    metrics = ['MAE', 'MSE', 'RMSE', 'MAPE']
    colors = {
        'MAE': 'gold',
        'MSE': 'royalblue',
        'RMSE': 'seagreen',
        'MAPE': 'tomato'
    }

    for metric in metrics:
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.barh(results_df['Bi·∫øn'], results_df[metric], color=colors.get(metric, 'gray'))
        ax.set_title(f'{metric} theo bi·∫øn ({start_date} ƒë·∫øn {end_date})')
        ax.set_xlabel(metric)
        ax.invert_yaxis()
        ax.grid(True)
        plt.tight_layout()

        metric_path = f"charts/metrics/{metric}_chart.png"
        plt.savefig(metric_path)
        plt.close()

        # M√£ h√≥a ·∫£nh bi·ªÉu ƒë·ªì ch·ªâ s·ªë
        with open(metric_path, "rb") as f:
            img_data = base64.b64encode(f.read()).decode("utf-8")
            img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 500px"/>'
            metric_image_tags.append(img_tag)

    # Hi·ªÉn th·ªã c√°c bi·ªÉu ƒë·ªì ch·ªâ s·ªë theo chi·ªÅu ngang
    html_code_metrics = '<div style="display: flex; overflow-x: auto;">' + "".join(metric_image_tags) + '</div>'
    display(HTML(html_code_metrics))

    # Hi·ªÉn th·ªã c√°c bi·ªÉu ƒë·ªì ƒë∆∞·ªùng D·ª± b√°o vs Th·ª±c t·∫ø
    html_code_forecast = '<div style="display: flex; overflow-x: auto;">' + "".join(forecast_image_tags) + '</div>'
    display(HTML(html_code_forecast))

else:
    print("‚ùå Kh√¥ng c√≥ k·∫øt qu·∫£ n√†o sau khi x·ª≠ l√Ω NaN.")

from google.colab import sheets
sheet = sheets.InteractiveSheet(df=results_df)

"""# **üìö 11. X√ÅC NH·∫¨N CH√âO (CROSS-VALIDATION) TRONG D·ª∞ B√ÅO CHU·ªñI TH·ªúI GIAN**

## **üìöüìö 11.1 B·∫£ng so s√°nh hi·ªáu su·∫•t d·ª± b√°o**
"""

from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np
import pandas as pd

# ==== H√†m t√≠nh MAPE ====
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    mask = (y_true != 0) & (~np.isnan(y_true)) & (~np.isnan(y_pred))
    return np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100

# ==== H√†m d·ª± b√°o ng√¢y th∆° ====
def naive_forecast(train, horizon):
    return [train.iloc[-1]] * horizon

# ==== Cross-validation: Expanding Window ====
def expanding_window_cv(series, forecast_func, initial_train_size, horizon, step=1):
    metrics = []
    for start in range(initial_train_size, len(series) - horizon, step):
        train = series[:start]
        test = series[start:start+horizon]
        pred = forecast_func(train, horizon)
        test = test.values
        pred = np.array(pred)

        mae = mean_absolute_error(test, pred)
        mse = mean_squared_error(test, pred)
        rmse = np.sqrt(mse)
        mape = mean_absolute_percentage_error(test, pred)
        metrics.append({'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})

    return pd.DataFrame(metrics).mean()

# ==== Cross-validation: Rolling Window ====
def rolling_window_cv(series, forecast_func, train_size, horizon, step=1):
    metrics = []
    for start in range(0, len(series) - train_size - horizon, step):
        train = series[start:start+train_size]
        test = series[start+train_size:start+train_size+horizon]
        pred = forecast_func(train, horizon)
        test = test.values
        pred = np.array(pred)

        mae = mean_absolute_error(test, pred)
        mse = mean_squared_error(test, pred)
        rmse = np.sqrt(mse)
        mape = mean_absolute_percentage_error(test, pred)
        metrics.append({'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})

    return pd.DataFrame(metrics).mean()

# ==== Thi·∫øt l·∫≠p khung th·ªùi gian ====
start_date = "2004-03-15"
end_date = "2004-03-20"
df_eval = df.loc[start_date:end_date]

# ==== C·∫•u h√¨nh ====
initial_train_size = 24  # t·ªëi thi·ªÉu 1 ng√†y (v√¨ d·ªØ li·ªáu theo gi·ªù)
horizon = 5
step = 1

# ==== K·∫øt qu·∫£ t·ªïng h·ª£p ====
expanding_results = []
rolling_results = []

for col in df_eval.columns:
    series = df_eval[col].dropna()
    if len(series) >= initial_train_size + horizon + 5:
        try:
            expanding_avg = expanding_window_cv(series, naive_forecast, initial_train_size, horizon, step)
            rolling_avg = rolling_window_cv(series, naive_forecast, initial_train_size, horizon, step)

            expanding_results.append({
                'Bi·∫øn': col,
                'MAE': expanding_avg['MAE'],
                'MSE': expanding_avg['MSE'],
                'RMSE': expanding_avg['RMSE'],
                'MAPE': expanding_avg['MAPE'],
                'Ph∆∞∆°ng ph√°p': 'Expanding'
            })
            rolling_results.append({
                'Bi·∫øn': col,
                'MAE': rolling_avg['MAE'],
                'MSE': rolling_avg['MSE'],
                'RMSE': rolling_avg['RMSE'],
                'MAPE': rolling_avg['MAPE'],
                'Ph∆∞∆°ng ph√°p': 'Rolling'
            })
        except Exception as e:
            print(f"‚ùå L·ªói v·ªõi bi·∫øn {col}: {e}")
    else:
        print(f"‚ö†Ô∏è Bi·∫øn {col} kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ CV (len={len(series)})")

# ==== Gh√©p v√† hi·ªÉn th·ªã k·∫øt qu·∫£ ====
cv_results_df = pd.DataFrame(expanding_results + rolling_results)
display(cv_results_df.sort_values(by=["Bi·∫øn", "Ph∆∞∆°ng ph√°p"]))

"""## **üìöüìö 11.2 Bi·ªÉu ƒë·ªì Cross- validation**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh
chart_dir = "charts/ema/cv"
os.makedirs(chart_dir, exist_ok=True)

# C√°c th√¥ng s·ªë chung
initial_train_size = 24
horizon = 5
step = 1

image_tags = []

# H√†m v·∫Ω bi·ªÉu ƒë·ªì Expanding ho·∫∑c Rolling cho m·ªôt ƒë·ªô d√†i chu·ªói nh·∫•t ƒë·ªãnh
def plot_cv_schedule(series_len, train_size, horizon, step, mode="expanding"):
    if mode == "expanding":
        split_points = list(range(train_size, series_len - horizon, step))
        title = "Expanding Window CV"
        filename = os.path.join(chart_dir, "all_expanding.png")
    else:  # rolling
        split_points = list(range(0, series_len - train_size - horizon, step))
        title = "Rolling Window CV"
        filename = os.path.join(chart_dir, "all_rolling.png")

    n_splits = len(split_points)
    fig, ax = plt.subplots(figsize=(12, 6))

    for idx, start in enumerate(split_points):
        if mode == "expanding":
            train_start, train_end = 0, start
            test_start, test_end = start, start + horizon
        else:
            train_start, train_end = start, start + train_size
            test_start, test_end = train_end, train_end + horizon

        ax.plot(range(train_start, train_end), [idx] * (train_end - train_start),
                marker='o', linestyle='None', color='blue', label='Training' if idx == 0 else "")
        ax.plot(range(test_start, test_end), [idx] * (test_end - test_start),
                marker='s', linestyle='None', color='red', label='Test' if idx == 0 else "")
        ax.annotate('', xy=(series_len-0.5, idx), xytext=(-0.5, idx),
                    arrowprops=dict(arrowstyle="->", color='gray', lw=1))

    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_xlabel("Ch·ªâ s·ªë quan s√°t theo th·ªùi gian")
    ax.set_ylabel("L·∫ßn ki·ªÉm th·ª≠")
    ax.set_yticks(range(n_splits))
    ax.set_xlim(-0.5, series_len - 0.5)
    ax.grid(True, linestyle='--', alpha=0.4)
    ax.legend(loc='upper right')

    plt.tight_layout()
    plt.savefig(filename)
    plt.close(fig)

    # Th√™m h√¨nh v√†o danh s√°ch HTML
    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right:30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# T√¨m m·ªôt chu·ªói c√≥ ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ƒë·∫°i di·ªán
for col in df_eval.columns:
    series = df_eval[col].dropna()
    if len(series) >= initial_train_size + horizon + 5:
        series_len = len(series)
        plot_cv_schedule(series_len, initial_train_size, horizon, step, mode="expanding")
        plot_cv_schedule(series_len, initial_train_size, horizon, step, mode="rolling")
        break  # ch·ªâ l·∫•y m·ªôt bi·∫øn ƒë·∫ßu ti√™n ƒë·ªß ƒëi·ªÅu ki·ªán

# Hi·ªÉn th·ªã HTML
html_code = '<div style="display: flex; flex-wrap: nowrap; overflow-x: auto;">' + ''.join(image_tags) + '</div>'
display(HTML(html_code))

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Chu·∫©n b·ªã d·ªØ li·ªáu
cv_metrics = cv_results_df.melt(
    id_vars=['Bi·∫øn', 'Ph∆∞∆°ng ph√°p'],
    value_vars=['MAE', 'MAPE', 'RMSE'],
    var_name='Ch·ªâ s·ªë',
    value_name='Gi√° tr·ªã'
)

# M√†u s·∫Øc
colors = ['#1f77b4', '#ff7f0e', '#2ca02c']  # Xanh, Cam, Xanh l√°

# ===== BI·ªÇU ƒê·ªí EXPANDING =====
fig1, axes1 = plt.subplots(1, 3, figsize=(18, 6))
plt.subplots_adjust(wspace=0.3)

expanding_data = cv_metrics[cv_metrics['Ph∆∞∆°ng ph√°p'] == 'Expanding']

for idx, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
    ax = axes1[idx]
    subset = expanding_data[expanding_data['Ch·ªâ s·ªë'] == metric]

    # V·∫Ω line plot v·ªõi markers
    ax.plot(subset['Bi·∫øn'], subset['Gi√° tr·ªã'],
            color=colors[idx], linewidth=3, marker='o',
            markersize=8, markerfacecolor='white',
            markeredgecolor=colors[idx], markeredgewidth=2)

    ax.set_title(f'{metric} - Expanding Window', fontsize=14, fontweight='bold')
    ax.set_xlabel("Bi·∫øn s·ªë", fontsize=12)
    ax.set_ylabel("Gi√° tr·ªã", fontsize=12)
    ax.tick_params(axis='x', rotation=45)
    ax.grid(True, alpha=0.3)

    # T√¥ m√†u n·ªÅn cho c√°c gi√° tr·ªã cao
    if len(subset) > 0:
        max_val = subset['Gi√° tr·ªã'].max()
        min_val = subset['Gi√° tr·ªã'].min()
        ax.axhspan(min_val, max_val * 0.3, alpha=0.1, color=colors[idx])

fig1.suptitle("Expanding Window Cross-Validation Results",
              fontsize=16, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# ===== BI·ªÇU ƒê·ªí ROLLING =====
fig2, axes2 = plt.subplots(1, 3, figsize=(18, 6))
plt.subplots_adjust(wspace=0.3)

rolling_data = cv_metrics[cv_metrics['Ph∆∞∆°ng ph√°p'] == 'Rolling']

for idx, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
    ax = axes2[idx]
    subset = rolling_data[rolling_data['Ch·ªâ s·ªë'] == metric]

    # V·∫Ω line plot v·ªõi markers
    ax.plot(subset['Bi·∫øn'], subset['Gi√° tr·ªã'],
            color=colors[idx], linewidth=3, marker='s',
            markersize=8, markerfacecolor='white',
            markeredgecolor=colors[idx], markeredgewidth=2)

    ax.set_title(f'{metric} - Rolling Window', fontsize=14, fontweight='bold')
    ax.set_xlabel("Bi·∫øn s·ªë", fontsize=12)
    ax.set_ylabel("Gi√° tr·ªã", fontsize=12)
    ax.tick_params(axis='x', rotation=45)
    ax.grid(True, alpha=0.3)

    # T√¥ m√†u n·ªÅn cho c√°c gi√° tr·ªã cao
    if len(subset) > 0:
        max_val = subset['Gi√° tr·ªã'].max()
        min_val = subset['Gi√° tr·ªã'].min()
        ax.axhspan(min_val, max_val * 0.3, alpha=0.1, color=colors[idx])

fig2.suptitle("Rolling Window Cross-Validation Results",
              fontsize=16, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# ===== PHI√äN B·∫¢N ƒê∆†N GI·∫¢N H·ªöN =====
# N·∫øu mu·ªën style ƒë∆°n gi·∫£n h∆°n
def plot_simple_version(method_name, data, fig_title):
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    method_data = data[data['Ph∆∞∆°ng ph√°p'] == method_name]

    for i, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
        subset = method_data[method_data['Ch·ªâ s·ªë'] == metric]

        axes[i].plot(subset['Bi·∫øn'], subset['Gi√° tr·ªã'],
                    'o-', linewidth=2, markersize=6)
        axes[i].set_title(metric)
        axes[i].set_xlabel('Bi·∫øn s·ªë')
        axes[i].set_ylabel('Gi√° tr·ªã')
        axes[i].tick_params(axis='x', rotation=45)
        axes[i].grid(True, alpha=0.3)

    plt.suptitle(fig_title, fontsize=14, fontweight='bold')
    plt.tight_layout()
    plt.show()

# G·ªçi h√†m ƒë·ªÉ v·∫Ω
print("=== EXPANDING WINDOW ===")
plot_simple_version('Expanding', cv_metrics, 'Expanding Window Results')

print("\n=== ROLLING WINDOW ===")
plot_simple_version('Rolling', cv_metrics, 'Rolling Window Results')

# Ki·ªÉm tra d·ªØ li·ªáu
print("\n=== TH√îNG TIN D·ªÆ LI·ªÜU ===")
print("Ph∆∞∆°ng ph√°p c√≥ s·∫µn:", cv_metrics['Ph∆∞∆°ng ph√°p'].unique())
print("S·ªë ƒëi·ªÉm d·ªØ li·ªáu Expanding:", len(cv_metrics[cv_metrics['Ph∆∞∆°ng ph√°p'] == 'Expanding']))
print("S·ªë ƒëi·ªÉm d·ªØ li·ªáu Rolling:", len(cv_metrics[cv_metrics['Ph∆∞∆°ng ph√°p'] == 'Rolling']))

"""## **üìöüìö 11.3 L∆∞u k·∫øt qu·∫£ Cross- validation**"""

# L∆∞u k·∫øt qu·∫£ cross-validation
cv_results_df.to_csv('cross_validation_results.csv', index=False)

# L∆∞u k·∫øt qu·∫£ ƒë√°nh gi√° m√¥ h√¨nh naive
results_df.to_csv('naive_forecast_evaluation.csv', index=False)

"""# **üìö 12. M√î H√åNH ARIMA**"""

# ================ M√î H√åNH ARIMA ================
print("\n\n=== M√î H√åNH ARIMA (2004-03-15 ƒë·∫øn 2004-03-20) ===")

from statsmodels.tsa.arima.model import ARIMA

# Ch·ªçn kho·∫£ng th·ªùi gian mong mu·ªën
start_date = '2004-03-15'
end_date = '2004-03-20'
time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

# H√†m x√¢y d·ª±ng m√¥ h√¨nh ARIMA
def fit_arima(series, order=(1, 1, 1)):
    """Fit m√¥ h√¨nh ARIMA v·ªõi c√°c tham s·ªë cho tr∆∞·ªõc"""
    model = ARIMA(series, order=order)
    fitted_model = model.fit()
    return fitted_model

# √Åp d·ª•ng cho 3 bi·∫øn ƒë·∫ßu ti√™n ƒë·ªÉ demo
for col in df_period.columns[:3]:
    try:
        print(f"\nƒêang x√¢y d·ª±ng m√¥ h√¨nh ARIMA cho {col}...")
        series = df_period[col].dropna()

        if len(series) >= 30:  # ƒê·∫£m b·∫£o ƒë·ªß d·ªØ li·ªáu
            model = fit_arima(series, order=(1, 1, 1))
            print(model.summary())

            # D·ª± b√°o 12 gi·ªù ti·∫øp theo
            forecast = model.forecast(steps=12)

            # V·∫Ω ƒë·ªì th·ªã
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(series.index, series, label='Th·ª±c t·∫ø')
            ax.plot(pd.date_range(series.index[-1], periods=13, freq='h')[1:],
                    forecast, label='D·ª± b√°o', color='red', marker='o')
            ax.set_title(f'D·ª± b√°o ARIMA cho {col} (2004-03-15 ƒë·∫øn 2004-03-20)')
            ax.legend()
            plt.grid(True)
            plt.show()
        else:
            print(f"Kh√¥ng ƒë·ªß d·ªØ li·ªáu cho {col} ƒë·ªÉ x√¢y d·ª±ng m√¥ h√¨nh ARIMA (ch·ªâ c√≥ {len(series)} quan s√°t)")

    except Exception as e:
        print(f"L·ªói khi x√¢y d·ª±ng ARIMA cho {col}: {str(e)}")

"""# **üìö 13. M√î H√åNH HOLT-WINTERS**"""

# ================ M√î H√åNH HOLT-WINTERS (2004-03-15 ƒë·∫øn 2004-03-20) ================
print("\n\n=== M√î H√åNH HOLT-WINTERS CHO KHO·∫¢NG TH·ªúI GIAN 2004-03-15 ƒê·∫æN 2004-03-20 ===")

from statsmodels.tsa.holtwinters import ExponentialSmoothing

def fit_holt_winters(series, seasonal_periods=24, trend='add', seasonal='add'):
    """X√¢y d·ª±ng m√¥ h√¨nh Holt-Winters"""
    model = ExponentialSmoothing(series,
                               trend=trend,
                               seasonal=seasonal,
                               seasonal_periods=seasonal_periods)
    return model.fit()

# L·ªçc d·ªØ li·ªáu ch·ªâ trong kho·∫£ng th·ªùi gian mong mu·ªën
time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

# √Åp d·ª•ng cho c√°c bi·∫øn c√≥ t√≠nh th·ªùi v·ª•
for col in ['PT08.S1(CO)', 'T', 'RH']:  # Ch·ªçn 3 bi·∫øn c√≥ t√≠nh th·ªùi v·ª• r√µ
    try:
        print(f"\nƒêang x√¢y d·ª±ng m√¥ h√¨nh Holt-Winters cho {col}...")
        series = df_period[col].dropna()

        if len(series) >= 24:  # C·∫ßn √≠t nh·∫•t 1 chu k·ª≥ m√πa
            # Fit model
            model = fit_holt_winters(series)
            print(model.summary())

            # D·ª± b√°o 12 gi·ªù ti·∫øp theo
            forecast = model.forecast(12)

            # V·∫Ω ƒë·ªì th·ªã
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(series.index, series, label='Th·ª±c t·∫ø', color='black', linewidth=2)
            ax.plot(pd.date_range(series.index[-1], periods=13, freq='H')[1:],
                    forecast, label='D·ª± b√°o', color='red', linestyle='--', linewidth=2)
            ax.set_title(f'D·ª± b√°o Holt-Winters cho {col}\n({start_date} ƒë·∫øn {end_date})')
            ax.set_xlabel('Th·ªùi gian')
            ax.set_ylabel('Gi√° tr·ªã')
            ax.legend()
            ax.grid(True)
            plt.tight_layout()
            plt.show()
        else:
            print(f"Kh√¥ng ƒë·ªß d·ªØ li·ªáu cho {col} (ch·ªâ c√≥ {len(series)} quan s√°t)")
    except Exception as e:
        print(f"L·ªói khi x√¢y d·ª±ng Holt-Winters cho {col}: {str(e)}")

"""# **üìö 14. KI·ªÇM TRA PH·∫¶N D∆Ø**"""

from statsmodels.stats.diagnostic import acorr_ljungbox

def check_residuals(residuals, title):
    """Ki·ªÉm tra t√≠nh nhi·ªÖu tr·∫Øng c·ªßa ph·∫ßn d∆∞"""
    print(f"\nKi·ªÉm tra ph·∫ßn d∆∞ cho {title}:")

    # Ki·ªÉm tra Ljung-Box
    lb_test = acorr_ljungbox(residuals.dropna(), lags=[10], return_df=True)
    print("Ljung-Box test:\n", lb_test)

    # V·∫Ω ACF c·ªßa ph·∫ßn d∆∞
    fig, ax = plt.subplots(figsize=(10, 4))
    plot_acf(residuals, ax=ax, lags=40)
    ax.set_title(f'ACF c·ªßa ph·∫ßn d∆∞ - {title}')
    plt.show()

    # V·∫Ω ph√¢n ph·ªëi ph·∫ßn d∆∞
    fig, ax = plt.subplots(figsize=(10, 4))
    sns.histplot(residuals.dropna(), kde=True, ax=ax)
    ax.set_title(f'Ph√¢n ph·ªëi ph·∫ßn d∆∞ - {title}')
    plt.show()

# √Åp d·ª•ng cho t·∫•t c·∫£ c√°c bi·∫øn
for col in df.columns:
    try:
        print(f"\n=== Ki·ªÉm tra ph·∫ßn d∆∞ cho bi·∫øn {col} ===")
        series = df[col].dropna()

        # Fit model ARIMA (c√≥ th·ªÉ thay ƒë·ªïi order t√πy theo t·ª´ng bi·∫øn)
        model = ARIMA(series, order=(1,1,1)).fit()

        # Ki·ªÉm tra ph·∫ßn d∆∞
        check_residuals(model.resid, f"ARIMA(1,1,1) - {col}")

    except Exception as e:
        print(f"L·ªói khi ki·ªÉm tra ph·∫ßn d∆∞ cho {col}: {str(e)}")

"""# **üìö 15. SO S√ÅNH MAPE GI·ªÆA C√ÅC PH∆Ø∆†NG PH√ÅP D·ª∞ B√ÅO**

## **üìöüìö 15.1 B·∫£ng so s√°nh**
"""

from statsmodels.tsa.arima.model import ARIMA
import pandas as pd

# H√†m d·ª± b√°o ARIMA
def arima_forecast(train, horizon):
    model = ARIMA(train, order=(1, 1, 1))  # ARIMA(1,1,1) ƒë∆°n gi·∫£n
    model_fit = model.fit()
    return model_fit.forecast(horizon)

# Danh s√°ch l∆∞u k·∫øt qu·∫£
arima_results = []

# L·∫∑p qua 3 bi·∫øn ƒë·∫ßu trong df_eval
for col in df_eval.columns[:3]:  # Gi·ªõi h·∫°n 3 bi·∫øn ƒë·∫ßu
    series = df_eval[col].dropna()

    if len(series) >= initial_train_size + horizon + 5:
        try:
            # N·∫øu l√† DatetimeIndex nh∆∞ng thi·∫øu t·∫ßn su·∫•t -> th√™m v√†o
            if isinstance(series.index, pd.DatetimeIndex) and series.index.freq is None:
                inferred_freq = pd.infer_freq(series.index)
                if inferred_freq:
                    series = series.asfreq(inferred_freq)
                else:
                    # N·∫øu kh√¥ng suy lu·∫≠n ƒë∆∞·ª£c freq, reset v·ªÅ d·∫°ng ch·ªâ m·ª•c s·ªë
                    series = series.reset_index(drop=True)

            # G·ªçi h√†m ƒë√°nh gi√° v·ªõi expanding window
            arima_avg = expanding_window_cv(series, arima_forecast, initial_train_size, horizon, step)

            # L∆∞u k·∫øt qu·∫£
            arima_results.append({
                'Bi·∫øn': col,
                'MAE': arima_avg['MAE'],
                'MSE': arima_avg['MSE'],
                'RMSE': arima_avg['RMSE'],
                'MAPE': arima_avg['MAPE'],
                'Ph∆∞∆°ng ph√°p': 'ARIMA'
            })
        except Exception as e:
            print(f"‚ùå L·ªói v·ªõi bi·∫øn {col}: {e}")

# K·∫øt h·ª£p k·∫øt qu·∫£ ARIMA v·ªõi c√°c ph∆∞∆°ng ph√°p kh√°c
final_results = pd.concat([
    all_results,
    pd.DataFrame(arima_results)
], ignore_index=True)

# Ghi k·∫øt qu·∫£ ra CSV
final_results.to_csv('final_forecast_comparison.csv', index=False)

# Hi·ªÉn th·ªã b·∫£ng k·∫øt qu·∫£ ƒë√£ s·∫Øp x·∫øp
display(final_results.sort_values(by=['Bi·∫øn', 'Ph∆∞∆°ng ph√°p']))

"""## **üìöüìö 15.2 Bi·ªÉu ƒë·ªì so s√°nh**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# H√†m d·ª± b√°o EMA c√≥ x·ª≠ l√Ω ch·ªâ m·ª•c th·ªùi gian
def ema_forecast(train, horizon):
    train = train.copy()

    # G√°n l·∫°i index n·∫øu ch∆∞a ph·∫£i DatetimeIndex ho·∫∑c thi·∫øu freq
    if not isinstance(train.index, pd.DatetimeIndex):
        train.index = pd.date_range(start='2000-01-01', periods=len(train), freq='D')
    elif train.index.freq is None:
        inferred_freq = pd.infer_freq(train.index)
        if inferred_freq:
            train.index = train.index.to_period(inferred_freq).to_timestamp()
        else:
            train.index = pd.date_range(start=train.index[0], periods=len(train), freq='D')

    model = ExponentialSmoothing(train, trend='add', seasonal=None)
    model_fit = model.fit()
    return model_fit.forecast(horizon)

# T√≠nh to√°n metrics cho EMA
ema_results = []
for col in df_eval.columns:
    series = df_eval[col].dropna()
    if len(series) >= initial_train_size + horizon + 5:
        try:
            ema_avg = expanding_window_cv(series, ema_forecast, initial_train_size, horizon, step)
            ema_results.append({
                'Bi·∫øn': col,
                'MAE': ema_avg['MAE'],
                'MSE': ema_avg['MSE'],
                'RMSE': ema_avg['RMSE'],
                'MAPE': ema_avg['MAPE'],
                'Ph∆∞∆°ng ph√°p': 'EMA'
            })
        except Exception as e:
            print(f"‚ùå L·ªói v·ªõi bi·∫øn {col}: {e}")

# K·∫øt h·ª£p k·∫øt qu·∫£
all_results = pd.concat([
    cv_results_df,
    pd.DataFrame(ema_results)
], ignore_index=True)

# V·∫Ω bi·ªÉu ƒë·ªì so s√°nh (ƒë√£ s·ª≠a l·ªói FutureWarning)
plt.figure(figsize=(14, 8))
sns.barplot(data=all_results, x='Bi·∫øn', y='MAPE', hue='Ph∆∞∆°ng ph√°p',
            palette='Set2', errorbar=None)  # <-- s·ª≠a l·ªói c·∫£nh b√°o ·ªü ƒë√¢y
plt.title('So s√°nh MAPE gi·ªØa c√°c ph∆∞∆°ng ph√°p d·ª± b√°o', fontsize=14, fontweight='bold')
plt.xticks(rotation=45)
plt.ylabel('MAPE (%)')
plt.xlabel('Bi·∫øn s·ªë')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

"""# **üìö 16. SIMPLE EXPOTENTIAL SMOOTHING (SES) FROM 2004-03-15 TO 2004-03-20**"""

print("\n\n=== SIMPLE EXPONENTIAL SMOOTHING (2004-03-15 ƒë·∫øn 2004-03-20) ===")

import warnings
warnings.simplefilter("ignore")
from statsmodels.tsa.holtwinters import SimpleExpSmoothing
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
import matplotlib.pyplot as plt
import pandas as pd
from IPython.display import display, HTML

# L·ªçc d·ªØ li·ªáu trong kho·∫£ng th·ªùi gian mong mu·ªën
time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

# √Åp d·ª•ng SES cho t·ª´ng bi·∫øn
for col in df_period.columns:
    try:
        print(f"\nƒêang √°p d·ª•ng SES cho {col}...")
        series = df_period[col].dropna()

        if len(series) >= 5:
            # Fit m√¥ h√¨nh
            model = SimpleExpSmoothing(series).fit()
            alpha = model.model.params['smoothing_level']
            print(f"Alpha t·ªëi ∆∞u: {alpha:.4f}")

            # D·ª± b√°o 5 b∆∞·ªõc
            forecast = model.forecast(5)

            # V·∫Ω ƒë·ªì th·ªã
            plt.figure(figsize=(12, 6))
            plt.plot(series.index, series, label='Th·ª±c t·∫ø')
            plt.plot(pd.date_range(series.index[-1], periods=6, freq='h')[1:],
                     forecast, label='D·ª± b√°o SES', color='red', marker='o')
            plt.title(f'Simple Exponential Smoothing cho {col}\n({start_date} ƒë·∫øn {end_date})')
            plt.legend()
            plt.grid(True)
            plt.show()

            # T√≠nh ƒë·ªô ch√≠nh x√°c n·∫øu ƒë·ªß d·ªØ li·ªáu
            commentary = ""
            if len(series) >= 10:
                train_size = int(len(series) * 0.8)
                train, test = series[:train_size], series[train_size:]
                model_train = SimpleExpSmoothing(train).fit()
                forecast_test = model_train.forecast(len(test))

                mae = mean_absolute_error(test, forecast_test)
                mape = mean_absolute_percentage_error(test, forecast_test)
                print(f"MAE: {mae:.4f}, MAPE: {mape:.4f}%")

                commentary += f"<b>ƒê√°nh gi√°:</b> Sai s·ªë MAE l√† {mae:.4f} v√† MAPE l√† {mape:.2f}%. "
            else:
                commentary += f"<b>Ghi ch√∫:</b> Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ƒë√°nh gi√° sai s·ªë (ch·ªâ c√≥ {len(series)} ƒëi·ªÉm). "

            # Nh·∫≠n x√©t xu h∆∞·ªõng d·ª± b√°o
            trend = "tƒÉng" if forecast[-1] > forecast[0] else "gi·∫£m" if forecast[-1] < forecast[0] else "·ªïn ƒë·ªãnh"
            commentary += f"<b>Xu h∆∞·ªõng d·ª± b√°o:</b> Chu·ªói th·ªùi gian c√≥ xu h∆∞·ªõng <span style='color:blue'>{trend}</span> trong 5 gi·ªù ti·∫øp theo."

            # Hi·ªÉn th·ªã nh·∫≠n x√©t
            display(HTML(f"<div style='padding:10px; background:#f9f9f9; border-left: 5px solid #00bcd4;'><p>{commentary}</p></div>"))

        else:
            print(f"Kh√¥ng ƒë·ªß d·ªØ li·ªáu cho {col} (ch·ªâ c√≥ {len(series)} quan s√°t)")

    except Exception as e:
        print(f"L·ªói khi √°p d·ª•ng SES cho {col}: {str(e)}")

    # D√≤ng ph√¢n c√°ch HTML
    display(HTML("<hr style='border:1px solid #ccc; margin: 20px 0;'>"))