# -*- coding: utf-8 -*-
"""Time series analysis ( ·∫¢nh g·ªôp).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UZsPzKHtn2PK5ZCL9mvmJefoL3KqkZbH

# **üìö 1. IMPORT TH∆Ø VI·ªÜN C·∫¶N THI·∫æT**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.metrics import mean_squared_error

# C√†i ƒë·∫∑t chung cho matplotlib v√† seaborn
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)

"""# **üìö 2. ƒê·ªåC D·ªÆ LI·ªÜU V√Ä X·ª¨ L√ç D·ªÆ LI·ªÜU**"""

# ƒê·ªçc d·ªØ li·ªáu t·ª´ URL
DATA_PATH = "https://redcap.huph.edu.vn/ddp/tsa/nhom4.csv"
df = pd.read_csv(DATA_PATH, sep=',', decimal='.', na_values=-200)

# Ch·ªçn c√°c c·ªôt c·∫ßn thi·∫øt
cols = ['Date', 'Time', 'CO(GT)', 'PT08.S1(CO)', 'NMHC(GT)', 'C6H6(GT)',
        'PT08.S2(NMHC)', 'NOx(GT)', 'PT08.S3(NOx)', 'NO2(GT)',
        'PT08.S4(NO2)', 'PT08.S5(O3)', 'T', 'RH', 'AH']
df = df[cols]

# Chuy·ªÉn ƒë·ªïi sang datetime v√† ƒë·∫∑t l√†m index
df['Timestamp'] = pd.to_datetime(df['Date'] + ' ' + df['Time'])
df = df.drop(columns=['Date', 'Time']).set_index('Timestamp')

# X·ª≠ l√Ω gi√° tr·ªã thi·∫øu
df = df.dropna()

# Hi·ªÉn th·ªã th√¥ng tin c∆° b·∫£n
print("Shape:", df.shape)
print("\nInfo:")
print(df.info())
print("\n5 d√≤ng ƒë·∫ßu ti√™n:")
print(df.head())

"""# **üìö 3. PLOT D·ªÆ LI·ªÜU TH√î**

## **üìöüìö 3.1 Plot ch·∫•t d·ªØ li·ªáu √¥ nhi·ªÖm**
"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh
if not os.path.exists("charts"):
    os.makedirs("charts")

pollutants = ['CO(GT)', 'NMHC(GT)', 'C6H6(GT)', 'NOx(GT)', 'NO2(GT)']
image_tags = []

for col in pollutants:
    fig, ax = plt.subplots(figsize=(10, 5))  # üëâ K√≠ch th∆∞·ªõc l·ªõn h∆°n (ngang 10 inch)
    ax.plot(df.index, df[col], linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel('Concentration')
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')  # üëâ L∆∞u g·ªçn s√°t n·ªôi dung
    plt.close(fig)

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        # üëâ ·∫¢nh hi·ªÉn th·ªã r·ªông h∆°n: 700px
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# üëâ HTML x·∫øp ·∫£nh ngang, cu·ªôn ngang ƒë∆∞·ª£c
html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""## **üìöüìö 3.2 Plot th·ªùi ti·∫øt**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh n·∫øu ch∆∞a c√≥
if not os.path.exists("charts"):
    os.makedirs("charts")

meteo = ['T', 'RH', 'AH']
image_tags = []

for col in meteo:
    fig, ax = plt.subplots(figsize=(10, 5))  # K√≠ch th∆∞·ªõc ·∫£nh ngang 10 inch, cao 5 inch
    ax.plot(df.index, df[col], color='orange', linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel(col)
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')  # L∆∞u ·∫£nh g·ªçn s√°t n·ªôi dung
    plt.close(fig)  # ƒê√≥ng ·∫£nh ƒë·ªÉ tr√°nh t·ªën b·ªô nh·ªõ

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# T·∫°o HTML ƒë·ªÉ hi·ªÉn th·ªã ·∫£nh theo h√†ng ngang v√† c√≥ th·ªÉ cu·ªôn ngang
html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""## **üìöüìö 3.3 Plot sensor**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh n·∫øu ch∆∞a c√≥
if not os.path.exists("charts"):
    os.makedirs("charts")

sensors = ['PT08.S1(CO)', 'PT08.S2(NMHC)', 'PT08.S3(NOx)', 'PT08.S4(NO2)', 'PT08.S5(O3)']
image_tags = []

for col in sensors:
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(df.index, df[col], color='green', linewidth=1.5)
    ax.set_title(col)
    ax.set_xlabel('Time')
    ax.set_ylabel(col)
    ax.grid(True)

    filename = f"charts/{col}.png"
    plt.savefig(filename, bbox_inches='tight')
    plt.close(fig)

    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right: 30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

html_code = '<div style="display: flex; overflow-x: auto;">' + "".join(image_tags) + '</div>'
display(HTML(html_code))

"""# **üìö 4. PH√ÇN T√çCH TH√ÄNH PH·∫¶N M√ôA V·ª§ (SEASONAL DECOMPOSITION)**"""

import matplotlib.pyplot as plt
import os
from statsmodels.tsa.seasonal import seasonal_decompose
from PIL import Image
from IPython.display import display
import math

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh decomposition n·∫øu ch∆∞a c√≥
save_folder = "charts/decomposition"
if not os.path.exists(save_folder):
    os.makedirs(save_folder)

saved_files = []

# V·∫Ω v√† l∆∞u t·ª´ng ·∫£nh decomposition
for col in df.columns:
    series = df[col].dropna()
    if len(series) >= 48:
        try:
            result = seasonal_decompose(series, model='additive', period=24)
            fig = result.plot()
            fig.suptitle(f"Decomposition of {col}", y=1.02)

            # ƒê·ªïi m√†u
            axes = fig.get_axes()
            axes[1].lines[0].set_color('red')
            axes[2].lines[0].set_color('green')
            axes[3].lines[0].set_color('orange')

            for ax in axes:
                ax.grid(True)

            plt.tight_layout()
            filename = os.path.join(save_folder, f"{col}_decomp.png")
            plt.savefig(filename, bbox_inches='tight')
            plt.close(fig)

            saved_files.append(filename)

        except Exception as e:
            print(f"‚ö† Kh√¥ng th·ªÉ decomposition bi·∫øn {col}: {e}")
    else:
        print(f"‚ö† Bi·∫øn {col} kh√¥ng ƒë·ªß d·ªØ li·ªáu.")

# G·ªôp t·∫•t c·∫£ ·∫£nh decomposition nh·ªè th√†nh 1 ·∫£nh l·ªõn, 2 ·∫£nh tr√™n 1 h√†ng
if saved_files:
    images = [Image.open(f) for f in saved_files]

    widths, heights = zip(*(img.size for img in images))

    imgs_per_row = 2
    rows = math.ceil(len(images) / imgs_per_row)

    max_width = max(widths)
    max_height = max(heights)

    total_width = imgs_per_row * max_width
    total_height = rows * max_height

    combined_img = Image.new('RGB', (total_width, total_height), 'white')

    for idx, img in enumerate(images):
        row = idx // imgs_per_row
        col = idx % imgs_per_row
        x = col * max_width
        y = row * max_height
        combined_img.paste(img, (x, y))

    display(combined_img)

else:
    print("‚ö† Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ g·ªôp v√† hi·ªÉn th·ªã.")

"""# **üìö 5. KI·ªÇM TRA T√çNH D·ª™NG (ADF TEST)**"""

for col in df.columns:
    series = df[col].dropna()
    if len(series) > 0:
        try:
            result = adfuller(series)
            print(f"\nVariable: {col}")
            print(f'ADF Statistic: {result[0]:.4f}')
            print(f'p-value: {result[1]:.4f}')
            print('Critical Values:')
            for key, value in result[4].items():
                print(f'   {key}: {value:.4f}')
            if result[1] > 0.05:
                print("=> Chu·ªói kh√¥ng d·ª´ng (non-stationary)")
            else:
                print("=> Chu·ªói d·ª´ng (stationary)")
        except Exception as e:
            print(f"‚ö† Kh√¥ng th·ªÉ ki·ªÉm tra ADF cho bi·∫øn {col}: {e}")
    else:
        print(f"‚ö† Bi·∫øn {col} kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ ki·ªÉm tra ADF.")

"""# **üìö 6. PH√âP SAI PH√ÇN (DIFFERENCING)**"""

import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
import math

print("\n\n=== PH√âP SAI PH√ÇN & V·∫º BI·ªÇU ƒê·ªí CHO T·ª™NG BI·∫æN (2004-03-15 ƒë·∫øn 2004-03-20) ===")

start_date = "2004-03-15"
end_date = "2004-03-20"

time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

cols = df_period.columns.tolist()
n_vars = len(cols)

# M·ªói bi·∫øn s·∫Ω c√≥ 2 bi·ªÉu ƒë·ªì (chu·ªói g·ªëc + sai ph√¢n ho·∫∑c ch·ªâ chu·ªói g·ªëc)
# 2 bi·∫øn tr√™n 1 h√†ng -> 4 bi·ªÉu ƒë·ªì tr√™n m·ªói h√†ng
plots_per_row = 4
vars_per_row = 2
n_rows = math.ceil(n_vars / vars_per_row)

fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(20, 5 * n_rows))
if n_rows == 1:
    axes = axes.reshape(1, -1)  # ƒê·∫£m b·∫£o axes l√† 2 chi·ªÅu

def apply_differencing(series, order=1, seasonal_order=None, seasonal_period=24):
    diff_series = series.copy()
    for _ in range(order):
        diff_series = diff_series.diff().dropna()
    if seasonal_order is not None:
        for _ in range(seasonal_order):
            diff_series = diff_series.diff(seasonal_period).dropna()
    return diff_series

for idx, col in enumerate(cols):
    row = idx // vars_per_row
    col_pos = idx % vars_per_row

    ax_orig = axes[row, col_pos*2]       # V·ªã tr√≠ bi·ªÉu ƒë·ªì chu·ªói g·ªëc
    ax_diff = axes[row, col_pos*2 + 1]  # V·ªã tr√≠ bi·ªÉu ƒë·ªì sai ph√¢n

    try:
        series = df_period[col].dropna()
        result = adfuller(series)
        pvalue = result[1]

        if pvalue > 0.05:
            # Kh√¥ng d·ª´ng ‚Üí √°p d·ª•ng sai ph√¢n
            diff_series = apply_differencing(series, order=1)
            diff_series = diff_series[(diff_series.index >= start_date) & (diff_series.index <= end_date)]

            # V·∫Ω chu·ªói g·ªëc
            series.plot(ax=ax_orig, color='black')
            ax_orig.set_title(f"[{col}] Chu·ªói g·ªëc\n({start_date} ƒë·∫øn {end_date})")
            ax_orig.grid(True)

            # V·∫Ω chu·ªói sai ph√¢n
            if not diff_series.empty:
                diff_series.plot(ax=ax_diff, color='black')
                ax_diff.set_title(f"[{col}] Sai ph√¢n b·∫≠c 1\n({start_date} ƒë·∫øn {end_date})")
                ax_diff.grid(True)
            else:
                ax_diff.text(0.5, 0.5, 'Kh√¥ng ƒë·ªß d·ªØ li·ªáu\nsau sai ph√¢n',
                             ha='center', va='center', transform=ax_diff.transAxes)
                ax_diff.set_title(f"[{col}] Sai ph√¢n b·∫≠c 1\n({start_date} ƒë·∫øn {end_date})")
                ax_diff.grid(False)
        else:
            # ƒê√£ d·ª´ng ‚Üí ch·ªâ v·∫Ω chu·ªói g·ªëc ·ªü c·∫£ 2 √¥ ƒë·ªÉ gi·ªØ layout
            series.plot(ax=ax_orig, color='black')
            ax_orig.set_title(f"[{col}] ƒê√£ d·ª´ng (ADF p={pvalue:.4f})\n({start_date} ƒë·∫øn {end_date})")
            ax_orig.grid(True)

            ax_diff.axis('off')  # ·∫®n tr·ª•c sai ph√¢n v√¨ kh√¥ng c√≥

    except Exception as e:
        ax_orig.text(0.5, 0.5, f'L·ªói v·ªõi bi·∫øn\n{col}\n{str(e)}', ha='center', va='center', transform=ax_orig.transAxes)
        ax_orig.set_title(f"[{col}] L·ªói")
        ax_diff.axis('off')

plt.tight_layout()
plt.show()

"""# **üìö 7. V·∫º ACF & PACF**"""

import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import math

cols = df.columns.tolist()
n_vars = len(cols)

vars_per_row = 2   # 2 bi·∫øn tr√™n m·ªói h√†ng
plots_per_row = vars_per_row * 2  # m·ªói bi·∫øn 2 bi·ªÉu ƒë·ªì (ACF + PACF)
n_rows = math.ceil(n_vars / vars_per_row)

fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(16, 5 * n_rows))
if n_rows == 1:
    axes = axes.reshape(1, -1)  # ƒê·∫£m b·∫£o 2 chi·ªÅu n·∫øu ch·ªâ 1 h√†ng

for idx, col in enumerate(cols):
    series = df[col].dropna()
    if len(series) < 50:
        print(f"‚ö† Bi·∫øn {col} kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ v·∫Ω ACF/PACF.")
        # ·∫®n 2 √¥ tr·ªëng d√†nh cho bi·∫øn n√†y
        row = idx // vars_per_row
        col_pos = idx % vars_per_row
        axes[row, col_pos*2].axis('off')
        axes[row, col_pos*2 + 1].axis('off')
        continue

    try:
        row = idx // vars_per_row
        col_pos = idx % vars_per_row

        ax_acf = axes[row, col_pos*2]
        ax_pacf = axes[row, col_pos*2 + 1]

        fig.suptitle(f"ACF v√† PACF c√°c bi·∫øn", fontsize=16, y=1.02)

        plot_acf(series, ax=ax_acf, lags=40, zero=False)
        ax_acf.set_title(f"ACF c·ªßa {col}")

        plot_pacf(series, ax=ax_pacf, lags=40, method='ywmle', zero=False)
        ax_pacf.set_title(f"PACF c·ªßa {col}")

    except Exception as e:
        print(f"‚ö† Kh√¥ng th·ªÉ v·∫Ω ACF/PACF cho bi·∫øn {col}: {e}")
        axes[row, col_pos*2].axis('off')
        axes[row, col_pos*2 + 1].axis('off')

# ·∫®n c√°c tr·ªëng c√≤n l·∫°i n·∫øu c√≥
total_plots = n_rows * plots_per_row
for i in range(n_vars, total_plots // 2):
    row = i // vars_per_row
    col_pos = i % vars_per_row
    axes[row, col_pos*2].axis('off')
    axes[row, col_pos*2 + 1].axis('off')

plt.tight_layout()
plt.show()

"""# **üìö 8. MOVING AVERAGE (TRUNG B√åNH TR∆Ø·ª¢T 24h)**"""

import matplotlib.pyplot as plt
import math

# C√°c bi·∫øn h·ª£p l·ªá (ƒë·ªß d·ªØ li·ªáu)
valid_cols = [col for col in df.columns if df[col].dropna().shape[0] >= 24]

# Th√¥ng s·ªë hi·ªÉn th·ªã
plots_per_row = 2
n_plots = len(valid_cols)
n_rows = math.ceil(n_plots / plots_per_row)

# T·∫°o figure l·ªõn
fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(16, 5 * n_rows))

# ƒê·∫£m b·∫£o axes lu√¥n l√† 2 chi·ªÅu
if n_rows == 1:
    axes = axes.reshape(1, -1)

for idx, col in enumerate(valid_cols):
    row = idx // plots_per_row
    col_pos = idx % plots_per_row
    ax = axes[row, col_pos]

    try:
        df[col].plot(ax=ax, label='Original', alpha=0.5)
        df[col].rolling(window=24).mean().plot(ax=ax, label='24h Rolling Mean', linewidth=2)

        ax.set_title(f"{col}", fontsize=12)
        ax.legend()
        ax.grid(True)
    except Exception as e:
        print(f"‚ö† Kh√¥ng th·ªÉ v·∫Ω Rolling Mean cho bi·∫øn {col}: {e}")
        ax.axis('off')

# ·∫®n c√°c √¥ tr·ªëng n·∫øu s·ªë bi·∫øn l·∫ª
if n_plots % plots_per_row != 0:
    for j in range(n_plots, n_rows * plots_per_row):
        row = j // plots_per_row
        col_pos = j % plots_per_row
        axes[row, col_pos].axis('off')

plt.suptitle("Moving Average (Trung b√¨nh tr∆∞·ª£t 24h)", fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

"""# **üìö 9. EXPONENTIAL MOVING AVERAGE (EMA)**




"""

import matplotlib.pyplot as plt
import math

# C√°c bi·∫øn h·ª£p l·ªá (ƒë·ªß d·ªØ li·ªáu)
valid_cols = [col for col in df.columns if df[col].dropna().shape[0] >= 24]

# Th√¥ng s·ªë hi·ªÉn th·ªã
plots_per_row = 2
n_plots = len(valid_cols)
n_rows = math.ceil(n_plots / plots_per_row)

# T·∫°o figure l·ªõn
fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(16, 5 * n_rows))

# ƒê·∫£m b·∫£o axes lu√¥n l√† 2 chi·ªÅu
if n_rows == 1:
    axes = axes.reshape(1, -1)

for idx, col in enumerate(valid_cols):
    row = idx // plots_per_row
    col_pos = idx % plots_per_row
    ax = axes[row, col_pos]

    try:
        df[col].plot(ax=ax, label='Original', alpha=0.5)
        df[col].ewm(span=24).mean().plot(ax=ax, label='EMA (span=24)', linewidth=2, color='red')

        ax.set_title(f"{col}", fontsize=12)
        ax.legend()
        ax.grid(True)
    except Exception as e:
        print(f"‚ö† Kh√¥ng th·ªÉ v·∫Ω EMA cho bi·∫øn {col}: {e}")
        ax.axis('off')

# ·∫®n √¥ tr·ªëng n·∫øu s·ªë bi·∫øn l·∫ª
if n_plots % plots_per_row != 0:
    for j in range(n_plots, n_rows * plots_per_row):
        row = j // plots_per_row
        col_pos = j % plots_per_row
        axes[row, col_pos].axis('off')

plt.suptitle("Exponential Moving Average (EMA, span=24)", fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

"""# **üìö 10. ƒêO ƒê·ªò CH√çNH X√ÅC D·ª∞ B√ÅO ( MAPE, MAE, MSE, RMSE)**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from sklearn.metrics import mean_absolute_error, mean_squared_error
from IPython.display import display, HTML
import base64
import math

# === 1. CH·ªåN KHO·∫¢NG TH·ªúI GIAN ƒê√ÅNH GI√Å ===
start_date = "2004-03-15"
end_date = "2004-03-20"
df_eval = df.loc[start_date:end_date]
df_pred = df_eval.shift(1)  # Naive forecast

# === 2. H√ÄM T√çNH MAPE ===
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    mask = (y_true != 0) & (~np.isnan(y_true)) & (~np.isnan(y_pred))
    return np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100

# === 3. T√çNH TO√ÅN CH·ªà S·ªê V√Ä L∆ØU K·∫æT QU·∫¢ ===
results = []
os.makedirs("charts/forecast_line", exist_ok=True)
os.makedirs("charts/metrics", exist_ok=True)

for col in df.columns:
    try:
        y_true = df_eval[col]
        y_pred = df_pred[col]
        valid_idx = y_true.notna() & y_pred.notna()
        y_true_clean = y_true[valid_idx]
        y_pred_clean = y_pred[valid_idx]

        if len(y_true_clean) > 0:
            mae = mean_absolute_error(y_true_clean, y_pred_clean)
            mse = mean_squared_error(y_true_clean, y_pred_clean)
            rmse = np.sqrt(mse)
            mape = mean_absolute_percentage_error(y_true_clean, y_pred_clean)
            results.append({'Bi·∫øn': col, 'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})
        else:
            print(f"‚ö†Ô∏è Bi·∫øn {col} kh√¥ng ƒë·ªß d·ªØ li·ªáu h·ª£p l·ªá.")
    except Exception as e:
        print(f"‚ùå L·ªói v·ªõi bi·∫øn {col}: {e}")

# === 4. X·ª¨ L√ù K·∫æT QU·∫¢ ===
results_df = pd.DataFrame(results)

if not results_df.empty:
    results_df = results_df.sort_values(by="MAPE", ascending=False)
    display(results_df)
    results_df.to_csv("charts/metrics/evaluation_results.csv", index=False)

    # === 5. G·ªòP C√ÅC BI·ªÇU ƒê·ªí D·ª∞ B√ÅO VS TH·ª∞C T·∫æ ===
    num_vars = len(results_df)
    cols_subplot = 2
    rows_subplot = math.ceil(num_vars / cols_subplot)

    fig, axs = plt.subplots(rows_subplot, cols_subplot, figsize=(16, 5 * rows_subplot))
    axs = axs.flatten()

    for i, result in enumerate(results_df.itertuples()):
        col = result.Bi·∫øn
        y_true = df_eval[col]
        y_pred = df_pred[col]
        valid_idx = y_true.notna() & y_pred.notna()
        y_true_clean = y_true[valid_idx]
        y_pred_clean = y_pred[valid_idx]

        axs[i].plot(y_true_clean.index, y_true_clean.values, label='Gi√° tr·ªã th·ª±c t·∫ø', color='black', linewidth=2)
        axs[i].plot(y_pred_clean.index, y_pred_clean.values, label='D·ª± b√°o (Naive)', color='orange', linestyle='--', linewidth=2)
        axs[i].set_title(f'{col}', fontsize=12)
        axs[i].set_xlabel('Th·ªùi gian')
        axs[i].set_ylabel('Gi√° tr·ªã')
        axs[i].legend()
        axs[i].grid(True)

    for j in range(i + 1, len(axs)):
        fig.delaxes(axs[j])

    plt.tight_layout()
    forecast_path = "charts/forecast_line/all_forecasts_combined.png"
    plt.savefig(forecast_path)
    plt.close()

    with open(forecast_path, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        display(HTML(f'<h3>Bi·ªÉu ƒë·ªì D·ª± b√°o vs Th·ª±c t·∫ø</h3><img src="data:image/png;base64,{img_data}" style="border:1px solid #ccc; width:1000px"/>'))

    # === 6. G·ªòP BI·ªÇU ƒê·ªí CH·ªà S·ªê MAE, MSE, RMSE, MAPE ===
    fig, axs = plt.subplots(2, 2, figsize=(14, 10))
    axs = axs.flatten()
    metrics = ['MAE', 'MSE', 'RMSE', 'MAPE']
    colors = ['gold', 'royalblue', 'seagreen', 'tomato']

    for i, metric in enumerate(metrics):
        axs[i].barh(results_df['Bi·∫øn'], results_df[metric], color=colors[i])
        axs[i].set_title(f'{metric} theo bi·∫øn ({start_date} - {end_date})')
        axs[i].set_xlabel(metric)
        axs[i].invert_yaxis()
        axs[i].grid(True)

    plt.tight_layout()
    metric_path = "charts/metrics/all_metrics_combined.png"
    plt.savefig(metric_path)
    plt.close()

    with open(metric_path, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        display(HTML(f'<h3>Bi·ªÉu ƒë·ªì c√°c ch·ªâ s·ªë ƒë√°nh gi√°</h3><img src="data:image/png;base64,{img_data}" style="border:1px solid #ccc; width:1000px"/>'))

else:
    print("‚ùå Kh√¥ng c√≥ k·∫øt qu·∫£ n√†o sau khi x·ª≠ l√Ω NaN.")

from google.colab import sheets
sheet = sheets.InteractiveSheet(df=results_df)

"""# **üìö 11. X√ÅC NH·∫¨N CH√âO (CROSS-VALIDATION) TRONG D·ª∞ B√ÅO CHU·ªñI TH·ªúI GIAN**

## **üìöüìö 11.1 B·∫£ng so s√°nh hi·ªáu su·∫•t d·ª± b√°o**
"""

from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np
import pandas as pd

# ==== H√†m t√≠nh MAPE ====
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    mask = (y_true != 0) & (~np.isnan(y_true)) & (~np.isnan(y_pred))
    return np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100

# ==== H√†m d·ª± b√°o ng√¢y th∆° ====
def naive_forecast(train, horizon):
    return [train.iloc[-1]] * horizon

# ==== Cross-validation: Expanding Window ====
def expanding_window_cv(series, forecast_func, initial_train_size, horizon, step=1):
    metrics = []
    for start in range(initial_train_size, len(series) - horizon, step):
        train = series[:start]
        test = series[start:start+horizon]
        pred = forecast_func(train, horizon)
        test = test.values
        pred = np.array(pred)

        mae = mean_absolute_error(test, pred)
        mse = mean_squared_error(test, pred)
        rmse = np.sqrt(mse)
        mape = mean_absolute_percentage_error(test, pred)
        metrics.append({'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})

    return pd.DataFrame(metrics).mean()

# ==== Cross-validation: Rolling Window ====
def rolling_window_cv(series, forecast_func, train_size, horizon, step=1):
    metrics = []
    for start in range(0, len(series) - train_size - horizon, step):
        train = series[start:start+train_size]
        test = series[start+train_size:start+train_size+horizon]
        pred = forecast_func(train, horizon)
        test = test.values
        pred = np.array(pred)

        mae = mean_absolute_error(test, pred)
        mse = mean_squared_error(test, pred)
        rmse = np.sqrt(mse)
        mape = mean_absolute_percentage_error(test, pred)
        metrics.append({'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'MAPE': mape})

    return pd.DataFrame(metrics).mean()

# ==== Thi·∫øt l·∫≠p khung th·ªùi gian ====
start_date = "2004-03-15"
end_date = "2004-03-20"
df_eval = df.loc[start_date:end_date]

# ==== C·∫•u h√¨nh ====
initial_train_size = 24  # t·ªëi thi·ªÉu 1 ng√†y (v√¨ d·ªØ li·ªáu theo gi·ªù)
horizon = 5
step = 1

# ==== K·∫øt qu·∫£ t·ªïng h·ª£p ====
expanding_results = []
rolling_results = []

for col in df_eval.columns:
    series = df_eval[col].dropna()
    if len(series) >= initial_train_size + horizon + 5:
        try:
            expanding_avg = expanding_window_cv(series, naive_forecast, initial_train_size, horizon, step)
            rolling_avg = rolling_window_cv(series, naive_forecast, initial_train_size, horizon, step)

            expanding_results.append({
                'Bi·∫øn': col,
                'MAE': expanding_avg['MAE'],
                'MSE': expanding_avg['MSE'],
                'RMSE': expanding_avg['RMSE'],
                'MAPE': expanding_avg['MAPE'],
                'Ph∆∞∆°ng ph√°p': 'Expanding'
            })
            rolling_results.append({
                'Bi·∫øn': col,
                'MAE': rolling_avg['MAE'],
                'MSE': rolling_avg['MSE'],
                'RMSE': rolling_avg['RMSE'],
                'MAPE': rolling_avg['MAPE'],
                'Ph∆∞∆°ng ph√°p': 'Rolling'
            })
        except Exception as e:
            print(f"‚ùå L·ªói v·ªõi bi·∫øn {col}: {e}")
    else:
        print(f"‚ö†Ô∏è Bi·∫øn {col} kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ CV (len={len(series)})")

# ==== Gh√©p v√† hi·ªÉn th·ªã k·∫øt qu·∫£ ====
cv_results_df = pd.DataFrame(expanding_results + rolling_results)
display(cv_results_df.sort_values(by=["Bi·∫øn", "Ph∆∞∆°ng ph√°p"]))

"""## **üìöüìö 11.2 Bi·ªÉu ƒë·ªì Cross- validation**"""

import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display
import base64

# T·∫°o th∆∞ m·ª•c l∆∞u ·∫£nh
chart_dir = "charts/ema/cv"
os.makedirs(chart_dir, exist_ok=True)

# C√°c th√¥ng s·ªë chung
initial_train_size = 24
horizon = 5
step = 1

image_tags = []

# H√†m v·∫Ω bi·ªÉu ƒë·ªì Expanding ho·∫∑c Rolling cho m·ªôt ƒë·ªô d√†i chu·ªói nh·∫•t ƒë·ªãnh
def plot_cv_schedule(series_len, train_size, horizon, step, mode="expanding"):
    if mode == "expanding":
        split_points = list(range(train_size, series_len - horizon, step))
        title = "Expanding Window CV"
        filename = os.path.join(chart_dir, "all_expanding.png")
    else:  # rolling
        split_points = list(range(0, series_len - train_size - horizon, step))
        title = "Rolling Window CV"
        filename = os.path.join(chart_dir, "all_rolling.png")

    n_splits = len(split_points)
    fig, ax = plt.subplots(figsize=(12, 6))

    for idx, start in enumerate(split_points):
        if mode == "expanding":
            train_start, train_end = 0, start
            test_start, test_end = start, start + horizon
        else:
            train_start, train_end = start, start + train_size
            test_start, test_end = train_end, train_end + horizon

        ax.plot(range(train_start, train_end), [idx] * (train_end - train_start),
                marker='o', linestyle='None', color='blue', label='Training' if idx == 0 else "")
        ax.plot(range(test_start, test_end), [idx] * (test_end - test_start),
                marker='s', linestyle='None', color='red', label='Test' if idx == 0 else "")
        ax.annotate('', xy=(series_len-0.5, idx), xytext=(-0.5, idx),
                    arrowprops=dict(arrowstyle="->", color='gray', lw=1))

    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_xlabel("Ch·ªâ s·ªë quan s√°t theo th·ªùi gian")
    ax.set_ylabel("L·∫ßn ki·ªÉm th·ª≠")
    ax.set_yticks(range(n_splits))
    ax.set_xlim(-0.5, series_len - 0.5)
    ax.grid(True, linestyle='--', alpha=0.4)
    ax.legend(loc='upper right')

    plt.tight_layout()
    plt.savefig(filename)
    plt.close(fig)

    # Th√™m h√¨nh v√†o danh s√°ch HTML
    with open(filename, "rb") as f:
        img_data = base64.b64encode(f.read()).decode("utf-8")
        img_tag = f'<img src="data:image/png;base64,{img_data}" style="margin-right:30px; border:1px solid #ccc; width: 700px"/>'
        image_tags.append(img_tag)

# T√¨m m·ªôt chu·ªói c√≥ ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ƒë·∫°i di·ªán
for col in df_eval.columns:
    series = df_eval[col].dropna()
    if len(series) >= initial_train_size + horizon + 5:
        series_len = len(series)
        plot_cv_schedule(series_len, initial_train_size, horizon, step, mode="expanding")
        plot_cv_schedule(series_len, initial_train_size, horizon, step, mode="rolling")
        break  # ch·ªâ l·∫•y m·ªôt bi·∫øn ƒë·∫ßu ti√™n ƒë·ªß ƒëi·ªÅu ki·ªán

# Hi·ªÉn th·ªã HTML
html_code = '<div style="display: flex; flex-wrap: nowrap; overflow-x: auto;">' + ''.join(image_tags) + '</div>'
display(HTML(html_code))

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Chu·∫©n b·ªã d·ªØ li·ªáu
cv_metrics = cv_results_df.melt(
    id_vars=['Bi·∫øn', 'Ph∆∞∆°ng ph√°p'],
    value_vars=['MAE', 'MAPE', 'RMSE'],
    var_name='Ch·ªâ s·ªë',
    value_name='Gi√° tr·ªã'
)

# M√†u s·∫Øc
colors = ['#1f77b4', '#ff7f0e', '#2ca02c']  # Xanh, Cam, Xanh l√°

# ===== BI·ªÇU ƒê·ªí EXPANDING =====
fig1, axes1 = plt.subplots(1, 3, figsize=(18, 6))
plt.subplots_adjust(wspace=0.3)

expanding_data = cv_metrics[cv_metrics['Ph∆∞∆°ng ph√°p'] == 'Expanding']

for idx, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
    ax = axes1[idx]
    subset = expanding_data[expanding_data['Ch·ªâ s·ªë'] == metric]

    # V·∫Ω line plot v·ªõi markers
    ax.plot(subset['Bi·∫øn'], subset['Gi√° tr·ªã'],
            color=colors[idx], linewidth=3, marker='o',
            markersize=8, markerfacecolor='white',
            markeredgecolor=colors[idx], markeredgewidth=2)

    ax.set_title(f'{metric} - Expanding Window', fontsize=14, fontweight='bold')
    ax.set_xlabel("Bi·∫øn s·ªë", fontsize=12)
    ax.set_ylabel("Gi√° tr·ªã", fontsize=12)
    ax.tick_params(axis='x', rotation=45)
    ax.grid(True, alpha=0.3)

    # T√¥ m√†u n·ªÅn cho c√°c gi√° tr·ªã cao
    if len(subset) > 0:
        max_val = subset['Gi√° tr·ªã'].max()
        min_val = subset['Gi√° tr·ªã'].min()
        ax.axhspan(min_val, max_val * 0.3, alpha=0.1, color=colors[idx])

fig1.suptitle("Expanding Window Cross-Validation Results",
              fontsize=16, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# ===== BI·ªÇU ƒê·ªí ROLLING =====
fig2, axes2 = plt.subplots(1, 3, figsize=(18, 6))
plt.subplots_adjust(wspace=0.3)

rolling_data = cv_metrics[cv_metrics['Ph∆∞∆°ng ph√°p'] == 'Rolling']

for idx, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
    ax = axes2[idx]
    subset = rolling_data[rolling_data['Ch·ªâ s·ªë'] == metric]

    # V·∫Ω line plot v·ªõi markers
    ax.plot(subset['Bi·∫øn'], subset['Gi√° tr·ªã'],
            color=colors[idx], linewidth=3, marker='s',
            markersize=8, markerfacecolor='white',
            markeredgecolor=colors[idx], markeredgewidth=2)

    ax.set_title(f'{metric} - Rolling Window', fontsize=14, fontweight='bold')
    ax.set_xlabel("Bi·∫øn s·ªë", fontsize=12)
    ax.set_ylabel("Gi√° tr·ªã", fontsize=12)
    ax.tick_params(axis='x', rotation=45)
    ax.grid(True, alpha=0.3)

    # T√¥ m√†u n·ªÅn cho c√°c gi√° tr·ªã cao
    if len(subset) > 0:
        max_val = subset['Gi√° tr·ªã'].max()
        min_val = subset['Gi√° tr·ªã'].min()
        ax.axhspan(min_val, max_val * 0.3, alpha=0.1, color=colors[idx])

fig2.suptitle("Rolling Window Cross-Validation Results",
              fontsize=16, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# ===== PHI√äN B·∫¢N ƒê∆†N GI·∫¢N H·ªöN =====
# N·∫øu mu·ªën style ƒë∆°n gi·∫£n h∆°n
def plot_simple_version(method_name, data, fig_title):
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    method_data = data[data['Ph∆∞∆°ng ph√°p'] == method_name]

    for i, metric in enumerate(['MAE', 'MAPE', 'RMSE']):
        subset = method_data[method_data['Ch·ªâ s·ªë'] == metric]

        axes[i].plot(subset['Bi·∫øn'], subset['Gi√° tr·ªã'],
                    'o-', linewidth=2, markersize=6)
        axes[i].set_title(metric)
        axes[i].set_xlabel('Bi·∫øn s·ªë')
        axes[i].set_ylabel('Gi√° tr·ªã')
        axes[i].tick_params(axis='x', rotation=45)
        axes[i].grid(True, alpha=0.3)

    plt.suptitle(fig_title, fontsize=14, fontweight='bold')
    plt.tight_layout()
    plt.show()

# G·ªçi h√†m ƒë·ªÉ v·∫Ω
print("=== EXPANDING WINDOW ===")
plot_simple_version('Expanding', cv_metrics, 'Expanding Window Results')

print("\n=== ROLLING WINDOW ===")
plot_simple_version('Rolling', cv_metrics, 'Rolling Window Results')

# Ki·ªÉm tra d·ªØ li·ªáu
print("\n=== TH√îNG TIN D·ªÆ LI·ªÜU ===")
print("Ph∆∞∆°ng ph√°p c√≥ s·∫µn:", cv_metrics['Ph∆∞∆°ng ph√°p'].unique())
print("S·ªë ƒëi·ªÉm d·ªØ li·ªáu Expanding:", len(cv_metrics[cv_metrics['Ph∆∞∆°ng ph√°p'] == 'Expanding']))
print("S·ªë ƒëi·ªÉm d·ªØ li·ªáu Rolling:", len(cv_metrics[cv_metrics['Ph∆∞∆°ng ph√°p'] == 'Rolling']))

"""## **üìöüìö 11.3 L∆∞u k·∫øt qu·∫£ Cross- validation**"""

# L∆∞u k·∫øt qu·∫£ cross-validation
cv_results_df.to_csv('cross_validation_results.csv', index=False)

# L∆∞u k·∫øt qu·∫£ ƒë√°nh gi√° m√¥ h√¨nh naive
results_df.to_csv('naive_forecast_evaluation.csv', index=False)

"""# **üìö 12. M√î H√åNH ARIMA**"""

# ================ M√î H√åNH ARIMA ================
print("\n\n=== M√î H√åNH ARIMA (2004-03-15 ƒë·∫øn 2004-03-20) ===")

from statsmodels.tsa.arima.model import ARIMA

# Ch·ªçn kho·∫£ng th·ªùi gian mong mu·ªën
start_date = '2004-03-15'
end_date = '2004-03-20'
time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

# H√†m x√¢y d·ª±ng m√¥ h√¨nh ARIMA
def fit_arima(series, order=(1, 1, 1)):
    """Fit m√¥ h√¨nh ARIMA v·ªõi c√°c tham s·ªë cho tr∆∞·ªõc"""
    model = ARIMA(series, order=order)
    fitted_model = model.fit()
    return fitted_model

# √Åp d·ª•ng cho 3 bi·∫øn ƒë·∫ßu ti√™n ƒë·ªÉ demo
for col in df_period.columns[:3]:
    try:
        print(f"\nƒêang x√¢y d·ª±ng m√¥ h√¨nh ARIMA cho {col}...")
        series = df_period[col].dropna()

        if len(series) >= 30:  # ƒê·∫£m b·∫£o ƒë·ªß d·ªØ li·ªáu
            model = fit_arima(series, order=(1, 1, 1))
            print(model.summary())

            # D·ª± b√°o 12 gi·ªù ti·∫øp theo
            forecast = model.forecast(steps=12)

            # V·∫Ω ƒë·ªì th·ªã
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(series.index, series, label='Th·ª±c t·∫ø')
            ax.plot(pd.date_range(series.index[-1], periods=13, freq='h')[1:],
                    forecast, label='D·ª± b√°o', color='red', marker='o')
            ax.set_title(f'D·ª± b√°o ARIMA cho {col} (2004-03-15 ƒë·∫øn 2004-03-20)')
            ax.legend()
            plt.grid(True)
            plt.show()
        else:
            print(f"Kh√¥ng ƒë·ªß d·ªØ li·ªáu cho {col} ƒë·ªÉ x√¢y d·ª±ng m√¥ h√¨nh ARIMA (ch·ªâ c√≥ {len(series)} quan s√°t)")

    except Exception as e:
        print(f"L·ªói khi x√¢y d·ª±ng ARIMA cho {col}: {str(e)}")

"""# **üìö 13. M√î H√åNH HOLT-WINTERS**"""

# ================ M√î H√åNH HOLT-WINTERS (2004-03-15 ƒë·∫øn 2004-03-20) ================
print("\n\n=== M√î H√åNH HOLT-WINTERS CHO KHO·∫¢NG TH·ªúI GIAN 2004-03-15 ƒê·∫æN 2004-03-20 ===")

from statsmodels.tsa.holtwinters import ExponentialSmoothing

def fit_holt_winters(series, seasonal_periods=24, trend='add', seasonal='add'):
    """X√¢y d·ª±ng m√¥ h√¨nh Holt-Winters"""
    model = ExponentialSmoothing(series,
                               trend=trend,
                               seasonal=seasonal,
                               seasonal_periods=seasonal_periods)
    return model.fit()

# L·ªçc d·ªØ li·ªáu ch·ªâ trong kho·∫£ng th·ªùi gian mong mu·ªën
time_range = (df.index >= start_date) & (df.index <= end_date)
df_period = df.loc[time_range]

# √Åp d·ª•ng cho c√°c bi·∫øn c√≥ t√≠nh th·ªùi v·ª•
for col in ['PT08.S1(CO)', 'T', 'RH']:  # Ch·ªçn 3 bi·∫øn c√≥ t√≠nh th·ªùi v·ª• r√µ
    try:
        print(f"\nƒêang x√¢y d·ª±ng m√¥ h√¨nh Holt-Winters cho {col}...")
        series = df_period[col].dropna()

        if len(series) >= 24:  # C·∫ßn √≠t nh·∫•t 1 chu k·ª≥ m√πa
            # Fit model
            model = fit_holt_winters(series)
            print(model.summary())

            # D·ª± b√°o 12 gi·ªù ti·∫øp theo
            forecast = model.forecast(12)

            # V·∫Ω ƒë·ªì th·ªã
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(series.index, series, label='Th·ª±c t·∫ø', color='black', linewidth=2)
            ax.plot(pd.date_range(series.index[-1], periods=13, freq='H')[1:],
                    forecast, label='D·ª± b√°o', color='red', linestyle='--', linewidth=2)
            ax.set_title(f'D·ª± b√°o Holt-Winters cho {col}\n({start_date} ƒë·∫øn {end_date})')
            ax.set_xlabel('Th·ªùi gian')
            ax.set_ylabel('Gi√° tr·ªã')
            ax.legend()
            ax.grid(True)
            plt.tight_layout()
            plt.show()
        else:
            print(f"Kh√¥ng ƒë·ªß d·ªØ li·ªáu cho {col} (ch·ªâ c√≥ {len(series)} quan s√°t)")
    except Exception as e:
        print(f"L·ªói khi x√¢y d·ª±ng Holt-Winters cho {col}: {str(e)}")

"""# **üìö 14. KI·ªÇM TRA PH·∫¶N D∆Ø**"""

from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.stats.diagnostic import acorr_ljungbox
import seaborn as sns
import matplotlib.pyplot as plt
import math

# Danh s√°ch l∆∞u tr·ªØ ph·∫ßn d∆∞ v√† ti√™u ƒë·ªÅ
residuals_list = []
titles = []

# B∆∞·ªõc 1: Fit ARIMA v√† l∆∞u ph·∫ßn d∆∞
for col in df.columns:
    try:
        series = df[col].dropna()
        model = ARIMA(series, order=(1,1,1)).fit()
        residuals_list.append(model.resid)
        titles.append(col)
        print(f"‚úÖ Ho√†n t·∫•t ARIMA cho {col}")
    except Exception as e:
        print(f"‚ùå L·ªói khi x·ª≠ l√Ω {col}: {e}")

# B∆∞·ªõc 2: T·∫°o ·∫£nh g·ªôp ACF v√† Histogram (2 c·ªôt m·ªói bi·∫øn, 2 bi·∫øn m·ªói h√†ng)
plots_per_row = 2
plots_per_block = 2  # ACF v√† Histogram
total_plots = len(residuals_list) * plots_per_block
n_rows = math.ceil(total_plots / plots_per_row)

fig, axes = plt.subplots(n_rows, plots_per_row, figsize=(16, 4 * n_rows))
if n_rows == 1:
    axes = axes.reshape(1, -1)

plot_idx = 0
for resid, title in zip(residuals_list, titles):
    # ACF plot
    row = plot_idx // plots_per_row
    col = plot_idx % plots_per_row
    ax = axes[row, col]
    plot_acf(resid.dropna(), ax=ax, lags=40)
    ax.set_title(f'ACF ph·∫ßn d∆∞ - {title}')
    plot_idx += 1

    # Histogram plot
    row = plot_idx // plots_per_row
    col = plot_idx % plots_per_row
    ax = axes[row, col]
    sns.histplot(resid.dropna(), kde=True, ax=ax)
    ax.set_title(f'Ph√¢n ph·ªëi ph·∫ßn d∆∞ - {title}')
    plot_idx += 1

# ·∫®n √¥ tr·ªëng n·∫øu s·ªë l∆∞·ª£ng bi·ªÉu ƒë·ªì kh√¥ng chia h·∫øt
for i in range(plot_idx, n_rows * plots_per_row):
    row = i // plots_per_row
    col = i % plots_per_row
    axes[row, col].axis('off')

plt.tight_layout()
os.makedirs("charts/residuals", exist_ok=True)
plt.savefig("charts/residuals/all_residuals_diagnostics.png", bbox_inches='tight')
plt.show()